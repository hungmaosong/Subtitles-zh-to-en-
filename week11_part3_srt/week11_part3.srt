1
00:00:00,466 --> 00:00:03,066
同學大家好

2
00:00:03,466 --> 00:00:06,233
那第三節就是由我來

3
00:00:06,266 --> 00:00:08,700
講一下那個期中考的範例code

4
00:00:08,733 --> 00:00:11,033
還有我們的作業4

5
00:00:11,166 --> 00:00:14,166
那因為我們的期末考會是用

6
00:00:14,333 --> 00:00:16,433
期中考還有

7
00:00:16,666 --> 00:00:20,166
作業三的那個內容去做一些修改

8
00:00:20,166 --> 00:00:22,500
然後當做我們的期末考題目

9
00:00:22,600 --> 00:00:23,733
所以就是

10
00:00:23,733 --> 00:00:26,566
等一下就是如果你期中考

11
00:00:26,566 --> 00:00:28,300
因為蠻多同學期中考

12
00:00:28,300 --> 00:00:29,600
第2題沒有寫出來的

13
00:00:29,600 --> 00:00:30,066
所以

14
00:00:30,066 --> 00:00:31,866
如果你第2題是之前沒有寫出來

15
00:00:31,866 --> 00:00:35,000
同學務必仔細聽懂那個

16
00:00:35,166 --> 00:00:38,233
期中考的第2題要怎麼去做對

17
00:00:39,066 --> 00:00:42,266
好那我將一個先從期中考開始講

18
00:00:42,266 --> 00:00:45,000
那下一個投影片是我們有放在

19
00:00:45,000 --> 00:00:46,800
Moodle上的那個

20
00:00:47,000 --> 00:00:49,866
投影片然後我答案都是會以這一份

21
00:00:50,166 --> 00:00:52,766
題目的範例code為主去講解

22
00:00:52,766 --> 00:00:55,100
那大家也不用擔心說那個

23
00:00:55,100 --> 00:00:57,366
因為我們期中考有分不同的題目嗎

24
00:00:57,366 --> 00:01:01,066
那我們都會同意用這一份為基準去

25
00:01:01,133 --> 00:01:02,366
那個出題

26
00:01:02,366 --> 00:01:04,200
所以不用擔心說如果你

27
00:01:04,466 --> 00:01:05,400
之前考的

28
00:01:05,400 --> 00:01:07,466
那個題目跟這一份不一樣怎麼辦

29
00:01:07,466 --> 00:01:09,033
你就是只要把這一份

30
00:01:09,066 --> 00:01:11,166
的內容搞懂就好了

31
00:01:12,300 --> 00:01:14,333
那我就簡單回顧一下我們那個

32
00:01:14,333 --> 00:01:15,166
期中考第二題

33
00:01:15,166 --> 00:01:16,833
在考什麼

34
00:01:16,900 --> 00:01:19,066
那第二題主要就是要請

35
00:01:19,066 --> 00:01:23,200
大家去找出我們輸入的data里面

36
00:01:23,333 --> 00:01:24,566
的最大值

37
00:01:24,566 --> 00:01:26,366
還有他的總和

38
00:01:26,566 --> 00:01:31,666
那還有就是由小到大去排序輸出

39
00:01:32,100 --> 00:01:33,866
主要都是這三個功能

40
00:01:34,066 --> 00:01:37,100
那我們的那個IO就是有Clock

41
00:01:37,333 --> 00:01:39,566
然後reset,data in

42
00:01:40,333 --> 00:01:41,200
然後data num

43
00:01:41,200 --> 00:01:43,633
data num是用來跟你說我們

44
00:01:43,700 --> 00:01:46,566
的那個data的序列有幾筆

45
00:01:46,566 --> 00:01:49,600
那你就是要去接收這幾筆的資料

46
00:01:49,600 --> 00:01:51,900
那他放的是2-6筆

47
00:01:52,133 --> 00:01:54,166
然後這個是你輸出的result

48
00:01:55,700 --> 00:01:58,233
好那簡單看一下時序圖就是

49
00:01:58,466 --> 00:02:00,533
在reset完的第一個正緣的時候

50
00:02:00,533 --> 00:02:01,300
我們的data num

51
00:02:01,300 --> 00:02:05,366
就會有一個值輸出

52
00:02:05,366 --> 00:02:07,366
代表我們接下來會有幾筆資料

53
00:02:07,366 --> 00:02:10,300
要接收 那在同一個cycle

54
00:02:10,300 --> 00:02:12,833
data in也會送來第一筆資料

55
00:02:12,933 --> 00:02:15,566
那因為我們的data num是2-6

56
00:02:15,566 --> 00:02:17,700
所以不可能你只接到一筆

57
00:02:17,800 --> 00:02:19,333
下一筆就要開始輸出了

58
00:02:19,333 --> 00:02:20,733
不會有這種情況

59
00:02:20,733 --> 00:02:22,766
所以這邊大家就是要放心

60
00:02:22,766 --> 00:02:24,533
把你的data num記下來

61
00:02:24,533 --> 00:02:26,433
然後把第一筆資料接起來

62
00:02:26,466 --> 00:02:28,233
那接下來再根據data num

63
00:02:28,566 --> 00:02:30,533
去接收你的資料

64
00:02:30,533 --> 00:02:32,133
就好 像這邊有3

65
00:02:32,133 --> 00:02:33,266
代表接下來

66
00:02:33,366 --> 00:02:35,700
三個cycle你都要去接收資料

67
00:02:35,700 --> 00:02:37,933
所以你先接到第1筆247

68
00:02:37,933 --> 00:02:41,100
第2筆3，第3筆92

69
00:02:42,133 --> 00:02:43,300
那接下來

70
00:02:43,533 --> 00:02:46,566
下一個第四個cycle就t3這邊

71
00:02:46,566 --> 00:02:48,766
然後開始去做你的輸出

72
00:02:48,766 --> 00:02:49,866
那剛有說

73
00:02:49,866 --> 00:02:50,300
我們

74
00:02:50,300 --> 00:02:52,900
第一個輸出是要輸出我們的最大值

75
00:02:53,166 --> 00:02:55,266
所以就要輸出247

76
00:02:55,566 --> 00:02:58,433
那在下一個cycle要輸出我們的總和

77
00:02:58,466 --> 00:03:01,400
也就是三個加起來342

78
00:03:01,866 --> 00:03:04,266
那接下來在下一個cycle T5這邊

79
00:03:04,266 --> 00:03:05,200
開始我們要

80
00:03:05,200 --> 00:03:08,633
由小到大輸出我們的那個data序列

81
00:03:08,800 --> 00:03:10,600
所以你要先輸出三

82
00:03:10,700 --> 00:03:12,900
然後在下一個cycle輸出92

83
00:03:12,900 --> 00:03:15,200
再下一個cycle輸出247

84
00:03:15,266 --> 00:03:16,666
然後接下來再下一個cycle

85
00:03:16,666 --> 00:03:18,100
就會有新的一筆data

86
00:03:18,100 --> 00:03:19,166
序列進來

87
00:03:19,166 --> 00:03:20,966
所以你要再去接收你的data

88
00:03:20,966 --> 00:03:22,400
那跟data in

89
00:03:22,533 --> 00:03:24,800
那這樣一直反覆直到模擬結束

90
00:03:24,800 --> 00:03:26,633
就可以完成第二題了

91
00:03:27,666 --> 00:03:29,433
那下面是他的state machine

92
00:03:29,500 --> 00:03:31,500
可以看到 就是一開始先在

93
00:03:31,700 --> 00:03:35,066
接受資料這邊 繞data num的cycle

94
00:03:35,066 --> 00:03:38,566
然後就進到輸出max,輸出sum

95
00:03:38,733 --> 00:03:41,266
那這兩個state都是一個cycle

96
00:03:41,366 --> 00:03:43,300
然後接下來你要去由小到大

97
00:03:43,300 --> 00:03:44,666
輸出 所以要花

98
00:03:44,766 --> 00:03:46,466
data num's cycle

99
00:03:46,466 --> 00:03:48,600
然後之後再回到你的receive data state

100
00:03:51,366 --> 00:03:54,366
好那我接下來講一下程式的部分

101
00:04:21,500 --> 00:04:25,166
抱歉 只有那個word pad可以開

102
00:04:25,533 --> 00:04:28,466
就將就一下

103
00:04:32,166 --> 00:04:34,466
這大小有同學看不到的嗎

104
00:04:35,366 --> 00:04:37,966
看不到同學舉手讓我知道一下

105
00:04:38,766 --> 00:04:41,500
好沒有 那就開始講解這一份程式

106
00:04:42,566 --> 00:04:43,366
那

107
00:04:43,533 --> 00:04:47,600
首先就是讓我們的IO有clock,reset,data num

108
00:04:47,600 --> 00:04:49,300
data in and result

109
00:04:50,133 --> 00:04:50,800
那接下來

110
00:04:50,800 --> 00:04:51,066
首先

111
00:04:51,066 --> 00:04:53,633
我們會需要宣告出我們的那個state

112
00:04:53,766 --> 00:04:55,133
那因為你有4個state

113
00:04:55,133 --> 00:04:57,833
就是我們這邊用2bit的去宣告

114
00:04:58,300 --> 00:04:59,066
那

115
00:04:59,066 --> 00:05:01,733
再來另外因為我們要把資料存起來

116
00:05:01,733 --> 00:05:05,366
在那個排序的那個state做輸出嘛

117
00:05:05,366 --> 00:05:07,266
我們這邊有宣告一個array

118
00:05:08,300 --> 00:05:10,600
這是value_array這個變數

119
00:05:10,966 --> 00:05:11,966
這個register

120
00:05:11,966 --> 00:05:13,566
那因為我們最多有6筆

121
00:05:13,566 --> 00:05:16,300
所以我們這邊就是開0冒號5

122
00:05:16,466 --> 00:05:17,333
這樣就是一定

123
00:05:17,333 --> 00:05:19,900
可以把我們輸入的資料都存進去

124
00:05:19,900 --> 00:05:21,200
不會超過

125
00:05:21,700 --> 00:05:24,400
然後另外我們因為要記住說我總共

126
00:05:24,400 --> 00:05:25,600
有幾筆Data

127
00:05:25,966 --> 00:05:27,666
當我排序的時候

128
00:05:27,666 --> 00:05:29,400
還有我那個接收資料的時候

129
00:05:29,400 --> 00:05:31,800
才知道要在那個state多少個cycle

130
00:05:31,800 --> 00:05:34,866
所以我們這邊有一個data num register

131
00:05:34,966 --> 00:05:38,166
是用來記錄輸入的那個data數量

132
00:05:38,466 --> 00:05:41,266
然後另外我為了要那個去

133
00:05:41,566 --> 00:05:44,400
控制我的那個array的寫入吧

134
00:05:44,400 --> 00:05:45,700
然後還有讀取之類的

135
00:05:45,700 --> 00:05:48,100
我這邊有宣告一個array_pointer

136
00:05:48,200 --> 00:05:49,000
用來記錄

137
00:05:49,000 --> 00:05:51,600
說我現在要操作的是哪一個array

138
00:05:51,666 --> 00:05:52,800
的位置

139
00:05:53,266 --> 00:05:55,133
那再來因為我們要記錄max

140
00:05:55,133 --> 00:05:57,266
所以我們這邊也是用一個register

141
00:05:57,300 --> 00:06:00,233
去記錄現在輸入資料的最大值

142
00:06:00,533 --> 00:06:03,833
那sum就是用來累加說我們現在

143
00:06:03,900 --> 00:06:05,833
輸入資料的總和

144
00:06:06,366 --> 00:06:07,266
那result的話

145
00:06:07,266 --> 00:06:09,866
就是因為我們達到在always block里去操作

146
00:06:09,866 --> 00:06:12,466
所以我們這邊宣告reg

147
00:06:13,466 --> 00:06:16,866
那state部分都是4個state,read data

148
00:06:16,866 --> 00:06:18,300
然後輸出Max

149
00:06:18,400 --> 00:06:21,233
輸出sum還有輸出排序結果

150
00:06:21,266 --> 00:06:22,433
4個state

151
00:06:22,800 --> 00:06:24,366
然後這邊我們是用那個老師

152
00:06:24,366 --> 00:06:25,666
教的那個

153
00:06:26,300 --> 00:06:29,100
combination跟sequential分開的寫法

154
00:06:29,100 --> 00:06:30,500
所以看到我們

155
00:06:30,800 --> 00:06:31,733
sequentia這邊

156
00:06:31,733 --> 00:06:34,000
我們state machine就是把current state

157
00:06:34,533 --> 00:06:36,300
小於等於Read data

158
00:06:36,333 --> 00:06:37,633
在reset的時候

159
00:06:37,766 --> 00:06:39,333
那若不是reset結束的話

160
00:06:39,333 --> 00:06:41,966
我們就是curence date小於等於next state

161
00:06:42,000 --> 00:06:42,766
那這個next state

162
00:06:42,766 --> 00:06:45,400
會由我們的combination電路來決定

163
00:06:46,400 --> 00:06:47,233
那在

164
00:06:47,533 --> 00:06:50,200
read data這個state的時候我們的next state

165
00:06:50,533 --> 00:06:52,333
就是要根據你像array pointer

166
00:06:52,333 --> 00:06:53,700
是不是已經數到

167
00:06:53,733 --> 00:06:56,300
data num reg記錄的數量

168
00:06:56,366 --> 00:06:58,133
比如說我們剛剛的範例里

169
00:06:58,133 --> 00:06:59,900
我們的data num是3

170
00:06:59,900 --> 00:07:02,900
那我們就會把3這數字存到data num

171
00:07:03,000 --> 00:07:03,800
register

172
00:07:03,966 --> 00:07:07,466
然後我們的array pointer就要從123去數

173
00:07:07,466 --> 00:07:09,400
數到一樣的數量的時候

174
00:07:09,733 --> 00:07:11,533
我們就是可以跳到下一個state

175
00:07:11,533 --> 00:07:12,866
ouput_max

176
00:07:13,066 --> 00:07:13,900
那如果還沒數

177
00:07:13,900 --> 00:07:15,933
到時候我們就是留在Read data

178
00:07:15,933 --> 00:07:18,200
再繼續做data的read

179
00:07:19,333 --> 00:07:22,066
好那接下進到output Max就是一個cycle

180
00:07:22,266 --> 00:07:24,766
所以我們next state就直接給output sum

181
00:07:25,333 --> 00:07:28,833
然後output sum一樣是一個cycle

182
00:07:29,000 --> 00:07:31,100
所以我們next state就是給下一個

183
00:07:31,200 --> 00:07:32,233
output sort

184
00:07:32,966 --> 00:07:34,500
那最後到output sort一樣

185
00:07:34,500 --> 00:07:38,600
我們要數到data num reg的cycle之後

186
00:07:38,600 --> 00:07:41,966
我們才會跳到跳回去read data state

187
00:07:41,966 --> 00:07:45,166
不然就我們都留在output sort這個state

188
00:07:45,900 --> 00:07:48,466
那以上就是我們的state machine

189
00:07:48,466 --> 00:07:49,966
有同學對這部分

190
00:07:50,200 --> 00:07:52,166
不懂需要再講一次的嗎

191
00:07:54,866 --> 00:07:56,900
好沒有 那我就繼續往後

192
00:07:57,066 --> 00:07:58,166
那再來是我們

193
00:07:58,166 --> 00:08:01,666
主要那個data運算處理的部分

194
00:08:01,666 --> 00:08:04,166
那這邊我們用sequential來撰寫

195
00:08:04,300 --> 00:08:06,166
那首先看到reset的時候

196
00:08:06,166 --> 00:08:08,900
我們就會先把我們的那個

197
00:08:09,100 --> 00:08:12,166
value array初始化成255

198
00:08:12,300 --> 00:08:15,100
那之所以要初始化成255 是因為

199
00:08:15,366 --> 00:08:19,033
我們希望那些沒有被填入值的

200
00:08:19,300 --> 00:08:20,666
array

201
00:08:21,000 --> 00:08:23,500
之後排去的時候被排在最後面

202
00:08:23,666 --> 00:08:24,866
那我們只會輸出

203
00:08:24,866 --> 00:08:26,200
假設我們data num是3

204
00:08:26,200 --> 00:08:27,833
我們只會輸出三筆

205
00:08:28,000 --> 00:08:33,166
那456那三個array的值都不會被輸出

206
00:08:33,400 --> 00:08:35,500
那因為我們是小到大嘛

207
00:08:35,500 --> 00:08:37,366
你說你一開始初始化成255

208
00:08:37,366 --> 00:08:39,300
那沒被更新值的array

209
00:08:39,300 --> 00:08:42,266
瑞就是會自動被排在456那邊

210
00:08:43,733 --> 00:08:44,966
好那data num

211
00:08:44,966 --> 00:08:46,933
這邊我們是初始化成7

212
00:08:46,933 --> 00:08:48,866
那其實這個然後初始化成多少

213
00:08:48,866 --> 00:08:50,066
應該都不影響

214
00:08:50,333 --> 00:08:53,200
然後arraay pointer初始化為0

215
00:08:53,333 --> 00:08:56,166
sum ,max, result都初始化為0

216
00:08:57,500 --> 00:09:01,566
那接下來進到那個我們的state machine

217
00:09:01,733 --> 00:09:02,533
的部分

218
00:09:02,533 --> 00:09:06,033
就是read data的時候我們的data num reg

219
00:09:06,366 --> 00:09:08,066
就要去給值

220
00:09:08,166 --> 00:09:10,766
那這個判斷是因為我們的TB

221
00:09:11,166 --> 00:09:15,666
在啊你的資料讀完之後

222
00:09:18,700 --> 00:09:20,766
就是在t1之後我們的data num

223
00:09:20,766 --> 00:09:22,200
是會變成0

224
00:09:22,533 --> 00:09:25,800
所以你如果你的data num是0

225
00:09:25,800 --> 00:09:28,400
代表現在是已經過了t1了

226
00:09:28,400 --> 00:09:30,300
所以你只有在t1的時候

227
00:09:30,300 --> 00:09:31,733
可以去更改你的

228
00:09:31,733 --> 00:09:33,066
data num reg的值

229
00:09:33,066 --> 00:09:34,700
不然就會接到錯的值

230
00:09:35,166 --> 00:09:37,500
那所以除非你現在是在t1

231
00:09:37,500 --> 00:09:40,366
也就是data num不等於0的時候

232
00:09:40,366 --> 00:09:43,466
你要去設定你的data num reg的值

233
00:09:43,500 --> 00:09:45,700
那這邊之所以不是設成data num

234
00:09:45,700 --> 00:09:48,366
而是data num - 1是因為

235
00:09:48,366 --> 00:09:49,600
雖然我剛剛是說我們的

236
00:09:49,600 --> 00:09:50,766
pointer可能是123

237
00:09:50,766 --> 00:09:51,900
數到3跟

238
00:09:52,066 --> 00:09:53,466
data num一樣

239
00:09:53,500 --> 00:09:56,266
但是因為我們實際電路運作會

240
00:09:56,366 --> 00:09:57,966
稍微多

241
00:09:58,100 --> 00:10:00,466
我們的那個0的那個index都沒有用到

242
00:10:00,466 --> 00:10:01,800
所以我們這邊其實是

243
00:10:01,800 --> 00:10:03,666
把data num - 1讓他

244
00:10:03,733 --> 00:10:06,266
去數的時候是012這樣數

245
00:10:06,266 --> 00:10:08,500
那我們data pointer也是012

246
00:10:08,500 --> 00:10:09,800
這樣比較省資源

247
00:10:10,933 --> 00:10:13,600
好那如果如果是不能改值的時候

248
00:10:13,600 --> 00:10:14,800
也就是不是t1的時候

249
00:10:14,800 --> 00:10:16,700
我的Data num Reg

250
00:10:16,800 --> 00:10:19,766
的值就是原維持他原本的值就好

251
00:10:20,200 --> 00:10:22,433
那這是Data num Reg的部分

252
00:10:22,500 --> 00:10:24,033
那再來是array pointer

253
00:10:24,333 --> 00:10:28,000
他就是如果還沒數到Data num Reg

254
00:10:28,266 --> 00:10:29,900
我就去加一

255
00:10:31,000 --> 00:10:32,866
那如果他像已經等於等於

256
00:10:32,866 --> 00:10:33,866
Data num Reg

257
00:10:33,866 --> 00:10:36,933
代表說我要跳到下一個是state了

258
00:10:36,933 --> 00:10:38,200
那這時候我們這邊有對他

259
00:10:38,200 --> 00:10:39,900
做一個歸零的動作

260
00:10:39,933 --> 00:10:41,266
因為我們後面

261
00:10:41,466 --> 00:10:44,100
我們排序輸出的時候我一定要從

262
00:10:44,133 --> 00:10:47,566
array0  array1  array2開始輸出

263
00:10:47,566 --> 00:10:48,766
所以我這邊就是

264
00:10:48,766 --> 00:10:50,466
在這里現在要做歸零

265
00:10:50,500 --> 00:10:52,333
但其實你在那個output max

266
00:10:52,333 --> 00:10:54,000
或output sum的時候

267
00:10:54,066 --> 00:10:56,000
去做歸零也可以

268
00:10:57,866 --> 00:10:58,066
哦

269
00:10:58,066 --> 00:11:00,800
那接下來是我們要計算sum的部分

270
00:11:00,800 --> 00:11:01,933
那這邊都是很簡單

271
00:11:01,933 --> 00:11:05,766
我們都是sum = sum + data_in就好了

272
00:11:06,066 --> 00:11:07,300
那只是同學

273
00:11:07,300 --> 00:11:09,366
要記得後面你已經輸出完

274
00:11:09,366 --> 00:11:12,866
你回到read data之前要把sum去歸零

275
00:11:12,866 --> 00:11:15,066
那第一次執行的時候因為我們

276
00:11:15,133 --> 00:11:16,500
reset的時候已經給他0了

277
00:11:16,500 --> 00:11:17,800
所以不會有問題

278
00:11:17,800 --> 00:11:21,500
但是你read完一輪的data之後

279
00:11:21,866 --> 00:11:23,666
嗯你要再回到read data之前

280
00:11:23,666 --> 00:11:26,066
記得去對他做歸零的動作

281
00:11:27,166 --> 00:11:29,066
好那這樣是max部分

282
00:11:29,100 --> 00:11:30,333
那一樣這邊我們

283
00:11:30,333 --> 00:11:32,600
因為前面已經把初始化為0

284
00:11:32,866 --> 00:11:34,966
所以你輸入的任一筆data

285
00:11:35,000 --> 00:11:37,466
一定都是會大於等於他們

286
00:11:37,466 --> 00:11:38,466
所以只要你現

287
00:11:38,466 --> 00:11:40,200
在輸入了data in大於Max

288
00:11:40,500 --> 00:11:42,000
我們就把Max的regester

289
00:11:42,000 --> 00:11:43,966
的值變成你現在輸入的data  in

290
00:11:45,166 --> 00:11:46,166
那後面

291
00:11:46,166 --> 00:11:49,600
你要輸入的第二筆data就要比這Max

292
00:11:49,900 --> 00:11:52,433
還要大他才會去更新他的值

293
00:11:52,533 --> 00:11:53,400
那用這種方法

294
00:11:53,400 --> 00:11:54,333
我們就可以把

295
00:11:54,333 --> 00:11:57,600
你輸入data里最大的值給記錄下來

296
00:11:59,600 --> 00:12:02,233
最後是排序的部分

297
00:12:02,333 --> 00:12:04,866
那剛剛我說到我們的那個value array

298
00:12:04,866 --> 00:12:08,166
我們開始都是把它預設成255

299
00:12:08,166 --> 00:12:10,966
就是我們那個8 bit的最大值

300
00:12:11,166 --> 00:12:12,866
所以你現在輸入了data

301
00:12:12,900 --> 00:12:16,033
我們就是要去找說他要擺在

302
00:12:16,166 --> 00:12:17,433
哪一個位置

303
00:12:18,533 --> 00:12:19,900
那假設你現在data in

304
00:12:19,900 --> 00:12:24,833
比我們的那個value array0還要小

305
00:12:24,933 --> 00:12:26,500
我們一次進來一筆哦

306
00:12:26,500 --> 00:12:28,000
所以在這樣的條件下

307
00:12:28,000 --> 00:12:28,966
我們就要找

308
00:12:28,966 --> 00:12:29,700
現在這個data

309
00:12:29,700 --> 00:12:31,700
他要插入哪一個位置就好

310
00:12:31,733 --> 00:12:32,066
那

311
00:12:32,066 --> 00:12:34,000
我們原本的array已經都是已經排序

312
00:12:34,000 --> 00:12:34,800
好的

313
00:12:35,133 --> 00:12:37,566
那現在在第一個cycle你就要去說

314
00:12:37,800 --> 00:12:40,033
例如說我的

315
00:12:41,000 --> 00:12:42,700
247輸入進來

316
00:12:42,700 --> 00:12:45,800
這時候我的那個value array全部都是255

317
00:12:45,800 --> 00:12:48,800
所以我就先去在這255 

318
00:12:48,800 --> 00:12:50,166
在這六個array當中

319
00:12:50,166 --> 00:12:52,400
找一個可以插入247的位置

320
00:12:52,700 --> 00:12:54,800
那這時候如果我發現他比value array

321
00:12:54,800 --> 00:12:55,966
0還要小

322
00:12:55,966 --> 00:12:57,566
那我先輸入了這一筆data

323
00:12:57,566 --> 00:12:59,533
他就是最小的嘛

324
00:12:59,533 --> 00:13:01,266
那他應該就要被插到

325
00:13:01,533 --> 00:13:03,800
那個value array 0的位置

326
00:13:03,800 --> 00:13:07,600
所以我就把value array 0更新成data in

327
00:13:08,000 --> 00:13:09,700
那我的value array 1

328
00:13:10,000 --> 00:13:13,266
要更新成0的 因為要往後推一格

329
00:13:16,566 --> 00:13:18,766
那我1要去存0的值

330
00:13:18,900 --> 00:13:20,666
2去存1的值

331
00:13:20,700 --> 00:13:21,866
3存成2的值

332
00:13:21,866 --> 00:13:23,500
4存成3的值

333
00:13:23,533 --> 00:13:24,800
以此類推

334
00:13:25,933 --> 00:13:28,800
哦那假設我現在data in比

335
00:13:29,000 --> 00:13:30,966
那個你的array0還要大

336
00:13:30,966 --> 00:13:33,400
那代表他的位置不會是0嗎

337
00:13:33,400 --> 00:13:34,933
我再往後找他的位置

338
00:13:34,933 --> 00:13:36,466
所以我就去看他是不是比

339
00:13:36,533 --> 00:13:38,400
value array1還要大

340
00:13:38,700 --> 00:13:42,133
如果如果他比value array 1還要小

341
00:13:42,133 --> 00:13:45,100
那代表我要把1的位置往後移

342
00:13:45,100 --> 00:13:49,166
然後把我這樣的data in放到value array1

343
00:13:49,166 --> 00:13:51,700
因為他比0還大然後又比1還小

344
00:13:51,700 --> 00:13:54,666
那他在新的位置就要把它放到1

345
00:13:55,200 --> 00:13:58,433
所以我就把value array 1更新成data in

346
00:13:58,600 --> 00:14:01,000
那其他的值都是往後推一格

347
00:14:01,000 --> 00:14:04,466
我把value array1的值存到value array 2

348
00:14:04,666 --> 00:14:07,200
value array 2的值存到value array3

349
00:14:07,300 --> 00:14:09,166
那一樣以此類推

350
00:14:10,400 --> 00:14:12,200
那如果他我現在data in

351
00:14:12,200 --> 00:14:15,000
又比0跟1都還要大

352
00:14:15,100 --> 00:14:17,166
那我就是再跟2去比

353
00:14:17,166 --> 00:14:19,800
那一樣如果他比2還要小的話

354
00:14:19,866 --> 00:14:22,466
他的位置就會變成在value array 2

355
00:14:22,466 --> 00:14:23,400
所以我就把value array2

356
00:14:23,400 --> 00:14:25,500
的值更新成data in

357
00:14:25,700 --> 00:14:29,800
然後原本2的值就是推到3 3的值推到4

358
00:14:30,100 --> 00:14:31,600
那後面就是做一樣的操作

359
00:14:31,600 --> 00:14:34,433
一直判斷到最後這樣子

360
00:14:35,500 --> 00:14:38,166
那這邊有同學不懂了嗎

361
00:14:40,600 --> 00:14:44,566
哦沒有的話那最後接下來sorting這邊

362
00:14:45,100 --> 00:14:47,666
對剛剛說的都還在那個Read data

363
00:14:47,666 --> 00:14:48,800
就是我們每輸入一筆

364
00:14:48,800 --> 00:14:50,233
我們就要去做判斷

365
00:14:50,366 --> 00:14:53,000
所以我們都還在Read data這個state里

366
00:14:53,100 --> 00:14:55,333
那等到你輸入了資料

367
00:14:55,333 --> 00:14:57,666
筆數已經等於你的data num之後

368
00:14:57,666 --> 00:15:00,833
你就是直接跳到下一個output Max

369
00:15:02,000 --> 00:15:03,800
那因為我用用一個

370
00:15:03,933 --> 00:15:06,466
那個Max的register去記錄他的值

371
00:15:06,500 --> 00:15:07,666
所以就直接把

372
00:15:07,966 --> 00:15:10,500
那個result小等於Max就好

373
00:15:11,566 --> 00:15:14,200
那大家下個cycle會跳到output sum

374
00:15:14,200 --> 00:15:16,100
那一樣我這邊已經

375
00:15:16,100 --> 00:15:18,400
用了register去記他的總和

376
00:15:18,400 --> 00:15:20,466
說的是result小於等於sum

377
00:15:21,133 --> 00:15:23,966
那接下來是output sort的時候

378
00:15:24,166 --> 00:15:26,200
這時候我都是一樣result

379
00:15:26,766 --> 00:15:29,700
<= vaule_array[array_pointer]因為我的

380
00:15:29,900 --> 00:15:33,066
那個Value array這個register是排序好的

381
00:15:33,133 --> 00:15:35,366
所以我就是從他的index 0開始

382
00:15:35,366 --> 00:15:36,300
輸出到data num

383
00:15:36,300 --> 00:15:37,300
就好

384
00:15:38,500 --> 00:15:39,400
那這邊

385
00:15:39,533 --> 00:15:42,733
這樣data num cycle輸出之後

386
00:15:42,733 --> 00:15:45,666
就完成我們的那個排序的輸出了

387
00:15:46,100 --> 00:15:48,866
那最後這邊可以看到有幾個

388
00:15:48,966 --> 00:15:50,066
判斷式

389
00:15:50,066 --> 00:15:52,833
在判斷array pointer是不是等於Data num reg

390
00:15:52,933 --> 00:15:53,666
如果是的話

391
00:15:53,666 --> 00:15:57,000
我就要把我的value array初始化255

392
00:15:57,100 --> 00:15:58,300
讓我下一次

393
00:15:58,366 --> 00:16:00,633
Read data之後才可以繼續做排序

394
00:16:01,066 --> 00:16:02,900
所以這邊有做一個判斷是

395
00:16:03,066 --> 00:16:05,966
如果你的array pointer等於等於data num reg

396
00:16:05,966 --> 00:16:08,666
就要把vulue array 0設成255

397
00:16:08,666 --> 00:16:10,500
不然就維持它的原值

398
00:16:10,700 --> 00:16:13,666
那一樣value array1也是 如果已經

399
00:16:13,933 --> 00:16:15,800
輸出完了我就要把它設成255

400
00:16:15,800 --> 00:16:17,266
不然就維持原值

401
00:16:17,800 --> 00:16:20,166
那sum and max一樣

402
00:16:20,166 --> 00:16:22,800
再回到read data之前你要再把他歸零

403
00:16:22,966 --> 00:16:24,900
不然如果你這邊max沒有歸零

404
00:16:24,900 --> 00:16:27,866
你下一筆data in就會受到影響

405
00:16:28,200 --> 00:16:30,466
因為照理說你下一組資料的

406
00:16:30,500 --> 00:16:31,833
第一筆一定會

407
00:16:32,066 --> 00:16:33,333
你要先把它記下來嘛

408
00:16:33,333 --> 00:16:35,366
你才可以跟後續的值去比較

409
00:16:35,400 --> 00:16:38,400
那如果你家max沒有把他歸零的話

410
00:16:38,600 --> 00:16:41,700
你就會留著上一組的Max

411
00:16:42,100 --> 00:16:43,500
那如果你今天輸入的data

412
00:16:43,500 --> 00:16:45,600
剛好又比他小

413
00:16:45,600 --> 00:16:47,766
那你就沒辦法蓋過去

414
00:16:47,866 --> 00:16:49,100
就會出錯

415
00:16:49,166 --> 00:16:50,633
那sum也是一樣

416
00:16:51,666 --> 00:16:53,166
如果你sum沒有歸零

417
00:16:53,166 --> 00:16:54,566
然後你後面一直加

418
00:16:54,566 --> 00:16:56,100
第一個你加的值會是錯的

419
00:16:56,100 --> 00:16:58,133
然後還有可能會發生overflow

420
00:16:58,133 --> 00:17:00,566
因為我們bit數是固定的

421
00:17:00,566 --> 00:17:02,800
所以記得就是這邊要記得

422
00:17:02,800 --> 00:17:05,166
要去做一個初始化的動作

423
00:17:05,466 --> 00:17:07,700
那大概就是期中考的程式

424
00:17:07,700 --> 00:17:08,766
大概就是這樣

425
00:17:09,133 --> 00:17:10,800
有同學有問題嗎

426
00:17:13,533 --> 00:17:14,166
如果

427
00:17:14,166 --> 00:17:16,800
這一份code有看不懂的同學都是一樣

428
00:17:16,800 --> 00:17:18,366
可以繼續來問

429
00:17:18,366 --> 00:17:19,433
那你就是

430
00:17:19,533 --> 00:17:22,466
你隨便隨便寄哪個助教都可以

431
00:17:22,500 --> 00:17:22,966
反正

432
00:17:22,966 --> 00:17:25,600
就是我們會看情況轉寄給那個

433
00:17:25,600 --> 00:17:26,866
期中考助教

434
00:17:27,466 --> 00:17:30,766
然後那我接下來就繼續講作業4

435
00:17:44,666 --> 00:17:47,300
好那我們的作業4要做的

436
00:17:47,300 --> 00:17:48,633
題目是那個

437
00:17:48,700 --> 00:17:51,866
基於邊緣的line average interpolation

438
00:17:52,300 --> 00:17:54,866
是做一個插補的一個程式

439
00:17:55,800 --> 00:17:57,600
那你先簡單介紹一下

440
00:17:57,600 --> 00:17:59,800
就是因為我們在存一些影像資料時

441
00:17:59,800 --> 00:18:02,966
可能為了節省那個成本

442
00:18:02,966 --> 00:18:04,800
我們可能會只存他的

443
00:18:05,200 --> 00:18:06,766
偶數行或是奇數行

444
00:18:06,766 --> 00:18:10,600
像是左邊這個圖他就是叫奇數行

445
00:18:10,700 --> 00:18:13,000
那偶數行的話他就是叫黑色

446
00:18:13,000 --> 00:18:14,366
代表他沒有值

447
00:18:15,000 --> 00:18:16,900
那但是我們要把影像

448
00:18:17,100 --> 00:18:17,733
顯示出來的時候

449
00:18:17,733 --> 00:18:19,366
我們就要對他做一個還原動作

450
00:18:19,366 --> 00:18:21,766
讓他偶數行跟奇數行都有

451
00:18:21,766 --> 00:18:24,866
不然你這樣看這視覺效果很差

452
00:18:24,866 --> 00:18:27,066
所以我們要透過一些演算法去做

453
00:18:27,166 --> 00:18:29,766
插補讓他得到他奇數行的值

454
00:18:29,766 --> 00:18:32,666
就可以編回右邊這個完整的圖像

455
00:18:34,166 --> 00:18:35,466
那我們這次

456
00:18:35,666 --> 00:18:37,166
用的演算法就是這個

457
00:18:37,166 --> 00:18:40,633
那個edge-based line average interpolation的方法

458
00:18:40,666 --> 00:18:42,500
就是他會根據邊緣去做一些

459
00:18:42,500 --> 00:18:43,666
條件的判斷

460
00:18:43,666 --> 00:18:46,033
來讓插補結果更好

461
00:18:47,400 --> 00:18:50,900
那這次的block overview就是這樣

462
00:18:50,900 --> 00:18:52,266
我們有兩個memory

463
00:18:52,366 --> 00:18:53,966
那第一個是

464
00:18:53,966 --> 00:18:57,800
在存原始灰階資料的Grayscale image memory

465
00:18:57,900 --> 00:19:00,733
那這memory就是只能讀而已

466
00:19:00,733 --> 00:19:02,466
而且他只能讀一次

467
00:19:02,466 --> 00:19:03,400
所以大家在

468
00:19:03,500 --> 00:19:04,666
設計的時候特別注意

469
00:19:04,666 --> 00:19:07,800
就是你讀出來的值一定要存好

470
00:19:07,933 --> 00:19:11,200
那不然就會就沒辦法再去讀他了

471
00:19:11,733 --> 00:19:14,366
那第二個是result image memory

472
00:19:14,366 --> 00:19:18,100
就是你要把你完成的資料寫進去

473
00:19:18,100 --> 00:19:20,600
那這邊要特別注意的是

474
00:19:20,666 --> 00:19:25,566
我們奇數行的值也要寫回去

475
00:19:25,566 --> 00:19:27,333
就是你不能只寫你

476
00:19:27,333 --> 00:19:29,966
處理好的那些插補的點

477
00:19:30,000 --> 00:19:31,000
你就是整張圖

478
00:19:31,000 --> 00:19:33,366
都要寫回這個result image memory

479
00:19:34,000 --> 00:19:35,466
然後你也可以利用他

480
00:19:35,466 --> 00:19:36,766
來做一個暫存的功能

481
00:19:36,766 --> 00:19:38,400
如果你想要節省資源

482
00:19:38,400 --> 00:19:40,500
不要開那麼多register的話

483
00:19:40,533 --> 00:19:43,966
你現在讀出來這些gray scale的值

484
00:19:44,000 --> 00:19:46,333
你就是可以先利用這邊做一個暫存

485
00:19:46,333 --> 00:19:48,466
這樣 不然你這邊只能讀一次

486
00:19:48,466 --> 00:19:51,366
你如果全部用那個register存的話

487
00:19:51,366 --> 00:19:53,100
面積就會比較大

488
00:19:54,333 --> 00:19:55,800
好然後帶大家看一下腳位

489
00:19:55,800 --> 00:19:58,566
就我們一樣這次也是正緣同步電路

490
00:19:58,666 --> 00:20:02,366
然後那個Active high的asychronous reset

491
00:20:02,600 --> 00:20:04,700
那require信號是用來

492
00:20:04,733 --> 00:20:08,200
跟那個Grayscale memory要值用的

493
00:20:08,366 --> 00:20:10,666
然後後面會講解他的時序

494
00:20:10,933 --> 00:20:11,733
然後in data

495
00:20:11,733 --> 00:20:14,000
就是從Grayscale memory

496
00:20:14,133 --> 00:20:17,866
讀出來的那個圖像資料的值

497
00:20:18,766 --> 00:20:21,733
那再來是Result image memory的控制訊號

498
00:20:21,733 --> 00:20:22,833
有wen

499
00:20:23,000 --> 00:20:26,166
就用來告訴他你是要做read還是write

500
00:20:26,533 --> 00:20:28,200
那當wen是0的時候

501
00:20:28,200 --> 00:20:31,000
代表你是要去讀Result memory

502
00:20:31,133 --> 00:20:34,466
那如果wen是1代表只要對他做寫入

503
00:20:34,933 --> 00:20:35,866
那addr

504
00:20:35,866 --> 00:20:38,366
就是你要操作的那個

505
00:20:38,366 --> 00:20:40,600
result image memory的位置

506
00:20:41,600 --> 00:20:42,766
那data_wr

507
00:20:42,766 --> 00:20:46,066
就是你要寫進result image memory的值

508
00:20:46,300 --> 00:20:49,600
data_rd就是從result image memory讀出來的

509
00:20:49,966 --> 00:20:52,733
圖像值 那最後有一個done訊號

510
00:20:52,733 --> 00:20:53,666
就是當你

511
00:20:53,666 --> 00:20:54,166
已經

512
00:20:54,166 --> 00:20:56,466
確定你把所有正確答案都寫到result image memory

513
00:20:56,466 --> 00:20:58,500
的時候你就把done

514
00:20:58,700 --> 00:21:01,833
拉成high TB就會開始做驗證

515
00:21:04,200 --> 00:21:07,900
好那接下來講一下這個那個edge-based

516
00:21:08,300 --> 00:21:11,300
line interpolation的那個演算法

517
00:21:11,466 --> 00:21:14,533
那首先我們測資會給你的

518
00:21:14,533 --> 00:21:17,200
是一張32*16的圖

519
00:21:17,466 --> 00:21:19,700
那他就是都只有奇數行

520
00:21:19,933 --> 00:21:21,166
那我們就是

521
00:21:21,166 --> 00:21:22,700
要把這32*16

522
00:21:22,700 --> 00:21:24,700
圖的偶數行插補出來

523
00:21:24,733 --> 00:21:26,800
那插補完的話就變3

524
00:21:26,800 --> 00:21:29,933
32*31的一個結果

525
00:21:29,933 --> 00:21:31,066
那我們再把這個結果

526
00:21:31,066 --> 00:21:33,000
寫到我們的result image memory

527
00:21:33,166 --> 00:21:35,466
就可以完成這次的題目

528
00:21:37,366 --> 00:21:38,400
那

529
00:21:38,400 --> 00:21:41,800
假設我們今天要插補的是這個黑點

530
00:21:42,500 --> 00:21:45,966
那它上面兩排我們會有

531
00:21:46,200 --> 00:21:48,700
原始測資讀出來的值嗎

532
00:21:48,700 --> 00:21:52,500
就是我們的那個奇數行的值是有的

533
00:21:52,500 --> 00:21:55,000
那藍色這一行是沒有值

534
00:21:55,000 --> 00:21:56,266
你要自己插補

535
00:21:56,400 --> 00:21:58,100
所以我們插補這黑點的話

536
00:21:58,100 --> 00:22:01,466
我們都會利用他上面這一排的ABC

537
00:22:01,733 --> 00:22:04,066
和下面那一列的d e f

538
00:22:04,333 --> 00:22:06,366
這幾個點去做條件判斷

539
00:22:06,366 --> 00:22:08,200
來決定我要怎麼做插補

540
00:22:08,900 --> 00:22:11,466
那判斷方法是我會先去看

541
00:22:11,733 --> 00:22:14,500
他各個方向的插值

542
00:22:14,666 --> 00:22:18,466
就是a跟f這個斜角的絕對值

543
00:22:18,566 --> 00:22:22,300
b跟e的插值 還有c跟d的插值

544
00:22:22,500 --> 00:22:24,933
那利用這插值去判斷他是不是有

545
00:22:24,933 --> 00:22:26,366
發生邊緣的情況

546
00:22:26,366 --> 00:22:27,666
來做不同的

547
00:22:27,766 --> 00:22:28,700
插補

548
00:22:28,966 --> 00:22:32,400
那所以我得到這三個方向的值之後

549
00:22:32,400 --> 00:22:34,900
我們就要找出他的最小值

550
00:22:35,133 --> 00:22:37,500
那最小值代表他是最沒有邊緣

551
00:22:37,500 --> 00:22:38,300
那我們用

552
00:22:38,366 --> 00:22:40,633
他的值來做插補是最不容易

553
00:22:40,733 --> 00:22:43,066
造成一些破損情況的

554
00:22:43,800 --> 00:22:45,200
所以我算完d1

555
00:22:45,200 --> 00:22:45,900
d2,d3之後

556
00:22:45,900 --> 00:22:47,666
我就知道他們的最小值

557
00:22:47,700 --> 00:22:49,366
那如果d1是最小的話

558
00:22:49,366 --> 00:22:50,266
我就是用

559
00:22:50,366 --> 00:22:54,666
a加f除以2當做我插補那個點的值

560
00:22:54,933 --> 00:22:58,766
那如果d2是最小 用b加一除以2

561
00:22:58,766 --> 00:23:01,966
如果D3是最小 用c加d除以2

562
00:23:03,566 --> 00:23:06,066
好 那但是有一點要特別注意是

563
00:23:06,066 --> 00:23:07,600
如果我們在插補點

564
00:23:07,600 --> 00:23:11,433
這黑點是在左邊界或右邊界的話

565
00:23:11,500 --> 00:23:13,666
那他可能會沒有a or d

566
00:23:13,666 --> 00:23:15,500
或是沒有c or f

567
00:23:15,566 --> 00:23:18,100
像這個圖他是用左邊界為例

568
00:23:18,100 --> 00:23:21,066
所以他只有b c e f的點可以參考

569
00:23:21,200 --> 00:23:22,966
所以說這時候我們都是

570
00:23:23,133 --> 00:23:25,066
你若在左邊界或右邊界

571
00:23:25,066 --> 00:23:26,966
我們一律就是用(b+e)/2

572
00:23:26,966 --> 00:23:29,100
當做這個黑點的插補值

573
00:23:29,166 --> 00:23:31,066
就不用再做判斷了

574
00:23:32,466 --> 00:23:35,033
那我們的演唱法就是這樣

575
00:23:35,533 --> 00:23:36,566
那接下來講一下

576
00:23:36,566 --> 00:23:39,566
那個資料輸入的時序部分

577
00:23:40,066 --> 00:23:43,500
首先是那個grayscale image memory的讀取

578
00:23:43,600 --> 00:23:46,200
那可以看到在t1的時候

579
00:23:46,500 --> 00:23:49,633
這邊我們將require信號拉為high

580
00:23:50,533 --> 00:23:54,466
那這個時候TB就會在t2的時候把

581
00:23:54,766 --> 00:23:56,666
開始給你一個row的值

582
00:23:56,666 --> 00:23:58,566
就是你只要拉高require一次

583
00:23:58,566 --> 00:24:00,233
他就一次給你一個row

584
00:24:00,366 --> 00:24:01,466
所以你就是要

585
00:24:01,500 --> 00:24:03,966
做好準備你去處理這個row的資料

586
00:24:03,966 --> 00:24:06,700
不管是把存到register或是存到

587
00:24:06,800 --> 00:24:09,300
memory或是直接做計算

588
00:24:09,300 --> 00:24:11,600
就是他就只會給你這一次

589
00:24:11,600 --> 00:24:13,433
所以你讀完之後就要對

590
00:24:13,466 --> 00:24:15,733
這個row做你需要的處理

591
00:24:15,733 --> 00:24:18,366
才不會後面你讀不到值就不能再

592
00:24:18,366 --> 00:24:20,566
做操作

593
00:24:20,600 --> 00:24:23,066
但是那另外就是前幾次作業

594
00:24:23,066 --> 00:24:24,733
就是可能有同學不太懂

595
00:24:24,733 --> 00:24:25,600
就是

596
00:24:25,733 --> 00:24:29,100
我們TB的值都是在負緣給的嗎

597
00:24:29,100 --> 00:24:31,400
像這邊我是負緣給pixel0

598
00:24:31,400 --> 00:24:33,000
下一個負緣給pixel1

599
00:24:33,400 --> 00:24:34,466
那為什麼我們都會講

600
00:24:34,466 --> 00:24:35,766
我們的電路要在

601
00:24:35,766 --> 00:24:37,933
正緣去做同步操作

602
00:24:37,933 --> 00:24:39,666
是因為我負緣

603
00:24:39,666 --> 00:24:40,966
雖然我是負緣給值

604
00:24:40,966 --> 00:24:41,733
但是

605
00:24:41,733 --> 00:24:43,800
這個時候我們可以看 紅線附近

606
00:24:43,800 --> 00:24:45,633
他值是有在變化的

607
00:24:45,866 --> 00:24:47,266
然後披pixel0 and pixel1

608
00:24:47,266 --> 00:24:50,266
中間這邊 值都還在變化

609
00:24:50,266 --> 00:24:52,566
所以這時候他值是比較不穩定

610
00:24:52,666 --> 00:24:54,300
那如果你在這邊去做操作

611
00:24:54,300 --> 00:24:56,266
比較容易會發生一些錯誤

612
00:24:56,333 --> 00:24:58,100
所以TB在負緣給值

613
00:24:58,100 --> 00:25:01,166
那我們真正適合去存取他資料

614
00:25:01,166 --> 00:25:02,433
其實在正緣

615
00:25:02,700 --> 00:25:05,333
可以看到正緣這邊這條虛線對下來

616
00:25:05,333 --> 00:25:07,600
他值很穩定的是pixel0

617
00:25:07,766 --> 00:25:09,300
所以這時候我就取他的值

618
00:25:09,300 --> 00:25:10,666
是比較安全的

619
00:25:10,900 --> 00:25:12,066
那在下一個正緣

620
00:25:12,066 --> 00:25:14,400
可以讓我這個虛線對下來

621
00:25:14,500 --> 00:25:17,166
左右這邊都是pixel1 就很穩定

622
00:25:17,166 --> 00:25:19,600
所以我們雖然TB在負緣給

623
00:25:19,600 --> 00:25:21,000
但是請同學都是

624
00:25:21,000 --> 00:25:23,433
都在正緣去處理這些資料

625
00:25:24,500 --> 00:25:25,633
好那等到

626
00:25:25,766 --> 00:25:28,466
一個row的data都輸入完之後

627
00:25:28,466 --> 00:25:30,300
然後pixel31輸入完

628
00:25:30,566 --> 00:25:31,866
再t3這邊

629
00:25:31,866 --> 00:25:34,166
那你就可以再把require拉高

630
00:25:34,333 --> 00:25:37,366
TB就會繼續給你後面的下一個row

631
00:25:37,366 --> 00:25:38,400
的pixel

632
00:25:38,933 --> 00:25:40,266
那另外就是

633
00:25:40,366 --> 00:25:43,866
如果你在還沒有輸入完之前

634
00:25:44,066 --> 00:25:46,066
就in_data還沒有輸入完一個row之前

635
00:25:46,066 --> 00:25:48,066
你把require拉高

636
00:25:48,066 --> 00:25:51,300
他是不會再直接給你第二個row的

637
00:25:51,533 --> 00:25:52,700
就是他不會記得說

638
00:25:52,700 --> 00:25:54,000
你這邊拉高幾個cycle

639
00:25:54,000 --> 00:25:55,000
就給你幾個row

640
00:25:55,000 --> 00:25:55,800
而是

641
00:25:55,800 --> 00:25:59,066
當他現在輸入 輸入完之後你再給require

642
00:25:59,266 --> 00:26:01,466
他才會再給你第二個row

643
00:26:01,533 --> 00:26:03,666
所以這邊請同學注意一下

644
00:26:05,100 --> 00:26:05,300
好

645
00:26:05,300 --> 00:26:09,333
那接下來是那個result image memory部分

646
00:26:09,333 --> 00:26:10,866
那這邊我們都是

647
00:26:10,966 --> 00:26:13,900
一個pixel會對應到一個位置

648
00:26:13,900 --> 00:26:17,166
然後我們總共有992個pixel要存進去

649
00:26:17,666 --> 00:26:19,266
總共有992個

650
00:26:20,533 --> 00:26:21,800
然後嗯

651
00:26:21,800 --> 00:26:24,400
首先我們看一下那個read mode的部分

652
00:26:24,766 --> 00:26:26,933
那如果你要做reed的就是把wen

653
00:26:26,933 --> 00:26:28,166
設成low

654
00:26:28,766 --> 00:26:30,866
然後Addr就是給

655
00:26:31,000 --> 00:26:33,100
你要的那一個位置

656
00:26:33,100 --> 00:26:34,666
你要讀的那個位置

657
00:26:34,766 --> 00:26:35,566
然後在下一個

658
00:26:35,566 --> 00:26:37,900
正緣就可以得到他的data

659
00:26:38,166 --> 00:26:40,300
那這邊一樣注意就是這樣你

660
00:26:40,766 --> 00:26:43,766
我們在這個正緣給addr跟wen

661
00:26:44,200 --> 00:26:47,300
之後可能負緣的時候data就會出來

662
00:26:47,300 --> 00:26:49,133
但是這時候一樣他比較不穩定

663
00:26:49,133 --> 00:26:50,100
所以請在

664
00:26:50,133 --> 00:26:52,366
下一個正緣去讀這個data

665
00:26:53,866 --> 00:26:56,233
那這邊是那個reading的部分

666
00:26:56,600 --> 00:26:58,066
那如果是寫入的話

667
00:26:58,066 --> 00:27:01,300
就是你在正元把wen拉高

668
00:27:01,300 --> 00:27:03,533
然後同時給你要寫的位置

669
00:27:03,533 --> 00:27:05,033
然後你要寫的data

670
00:27:05,200 --> 00:27:07,300
然後他的值就會被寫到我們的

671
00:27:07,300 --> 00:27:08,833
result image memory了

672
00:27:10,100 --> 00:27:12,066
那這次作業大概就是這樣

673
00:27:12,066 --> 00:27:14,000
有同學有疑問的嗎

674
00:27:16,733 --> 00:27:19,566
哦沒有 那我再再講一下我們這次

675
00:27:19,766 --> 00:27:22,566
比較特別有一個軟體驗證的部分

676
00:27:22,566 --> 00:27:23,866
可是要請大家寫

677
00:27:23,866 --> 00:27:26,033
軟體code去驗證你的電路

678
00:27:27,133 --> 00:27:30,800
那我們規定的語法是c or C++ or Python

679
00:27:31,000 --> 00:27:34,600
然後有幾點要求我講一下

680
00:27:34,800 --> 00:27:37,033
就是首先就是我們要會

681
00:27:37,166 --> 00:27:39,800
到時候認證助教會用軟體code去

682
00:27:39,933 --> 00:27:43,166
生成那個測資來做驗證

683
00:27:43,333 --> 00:27:45,566
所以就是你的

684
00:27:45,966 --> 00:27:48,500
輸入圖片的路徑就是固定用這個

685
00:27:48,533 --> 00:27:50,666
./image.jpg

686
00:27:51,133 --> 00:27:52,566
我們就會read

687
00:27:52,600 --> 00:27:55,600
這張圖進來做那個驗證

688
00:27:57,200 --> 00:28:00,300
然後再來就是你首先第一步就是

689
00:28:00,300 --> 00:28:03,266
你把這個image.jpg讀進來之後

690
00:28:03,266 --> 00:28:05,800
要把它轉成灰階

691
00:28:06,700 --> 00:28:08,366
那轉成灰階之後

692
00:28:08,400 --> 00:28:11,466
我們圖像資料是32*31

693
00:28:11,500 --> 00:28:13,633
所以就是要先把它做resize

694
00:28:14,100 --> 00:28:17,100
寬是32然後high是31

695
00:28:17,333 --> 00:28:19,033
那接下來因為我們

696
00:28:19,366 --> 00:28:21,233
我們有分那個

697
00:28:21,766 --> 00:28:24,700
原始的灰階資料是只有

698
00:28:24,900 --> 00:28:27,166
奇數行

699
00:28:27,333 --> 00:28:29,666
所以你需要把偶數行給移除掉

700
00:28:29,666 --> 00:28:31,966
讓他變成32*16

701
00:28:32,100 --> 00:28:33,566
這樣就可以得到我們

702
00:28:33,566 --> 00:28:35,333
那個符合我們電路

703
00:28:35,333 --> 00:28:36,566
的輸入

704
00:28:37,533 --> 00:28:39,366
那接下來就是請大家用

705
00:28:39,366 --> 00:28:42,033
軟體去制作我們剛剛說的那個

706
00:28:42,333 --> 00:28:46,266
那個edge baseline average interpolation的演算法

707
00:28:46,266 --> 00:28:49,766
把你自己生成的這個32*16的圖

708
00:28:49,966 --> 00:28:52,900
給插補成32*31

709
00:28:54,866 --> 00:28:57,333
那這樣的話我們就會有一個你自己

710
00:28:57,333 --> 00:28:58,700
對輸入圖

711
00:28:58,966 --> 00:29:02,466
處理好的32*16的data

712
00:29:02,466 --> 00:29:03,700
然後你用軟體演算法

713
00:29:03,700 --> 00:29:06,766
插補出來的32*31的圖像data

714
00:29:07,133 --> 00:29:08,466
那這兩個就是一個

715
00:29:08,466 --> 00:29:10,433
會是我們電路的輸入

716
00:29:10,866 --> 00:29:13,366
這32*16的就是我們電路的輸入

717
00:29:13,366 --> 00:29:16,000
所以大家就要把它存成image.dat

718
00:29:16,566 --> 00:29:19,700
那插補好的那個32*31的圖

719
00:29:19,733 --> 00:29:21,800
就是用我們用軟體做的

720
00:29:21,800 --> 00:29:23,266
理論上比較不容易出錯

721
00:29:23,266 --> 00:29:25,066
所以我們就是拿那個data

722
00:29:25,066 --> 00:29:25,900
當做我們的

723
00:29:25,933 --> 00:29:27,400
golden.dat

724
00:29:28,066 --> 00:29:29,700
那這兩個都是

725
00:29:30,100 --> 00:29:32,900
一個可以讓TB去當輸入資料

726
00:29:32,933 --> 00:29:34,000
然後接下來

727
00:29:34,000 --> 00:29:34,366
golden

728
00:29:34,366 --> 00:29:37,100
就是會跟你電路的輸出去做比對

729
00:29:37,133 --> 00:29:38,766
那咱們就可以得到一個軟

730
00:29:38,766 --> 00:29:40,200
體驗證生成資料

731
00:29:40,200 --> 00:29:41,833
去測試我們的電路

732
00:29:43,100 --> 00:29:45,166
那另外就是image.dat

733
00:29:45,166 --> 00:29:47,066
還有golden.dat的格式

734
00:29:47,066 --> 00:29:49,600
就是請大家參考那個助教給的

735
00:29:49,600 --> 00:29:52,366
我們TB原本就會附上一組image.dat

736
00:29:52,366 --> 00:29:53,700
跟golden.dat

737
00:29:54,066 --> 00:29:56,866
那請你們的格式就是要照著那個

738
00:29:56,866 --> 00:29:58,466
檔案的格式去寫

739
00:29:59,600 --> 00:30:02,566
然後命名的話就是主要的那個function

740
00:30:02,566 --> 00:30:03,966
請命名為main.c

741
00:30:03,966 --> 00:30:07,033
或者是main.CPP或main.py

742
00:30:07,800 --> 00:30:09,366
那如果你的code

743
00:30:09,600 --> 00:30:10,600
例如說python

744
00:30:10,600 --> 00:30:12,666
就要call一些比較特別的library

745
00:30:12,866 --> 00:30:15,700
那就是請你用readme.txt寫清楚

746
00:30:15,700 --> 00:30:17,800
然後到時候跟作業一起

747
00:30:17,800 --> 00:30:18,733
繳交 

748
00:30:18,733 --> 00:30:20,600
助教才知道怎麼去跑你的code

749
00:30:20,933 --> 00:30:22,666
或者你有一些特別的執行方法

750
00:30:22,666 --> 00:30:24,300
就是有時候寫在readme

751
00:30:24,533 --> 00:30:24,800


752
00:30:24,800 --> 00:30:28,500
才不會到時候跑不起來要在那個特別處理

753
00:30:28,500 --> 00:30:29,300
這樣

754
00:30:30,533 --> 00:30:33,166
好那講一下配分的部分

755
00:30:33,300 --> 00:30:35,733
那首先我們的funtional simulation

756
00:30:35,733 --> 00:30:38,033
這次是40%

757
00:30:38,200 --> 00:30:39,766
那我們有部分給分

758
00:30:39,766 --> 00:30:43,033
就是如果你的奇數行是對的

759
00:30:43,500 --> 00:30:44,700
就是有10分

760
00:30:44,700 --> 00:30:45,700
那這應該很簡單

761
00:30:45,700 --> 00:30:47,300
就是你奇數行讀進來

762
00:30:47,300 --> 00:30:50,333
你就把它寫到result image memory的正確位置

763
00:30:50,333 --> 00:30:51,700
你就10分了

764
00:30:51,966 --> 00:30:54,466
那接下來是boundary的部分

765
00:30:54,466 --> 00:30:56,466
就是左邊界或右邊界

766
00:30:57,066 --> 00:31:00,200
你有插補對的話就可以再拿10分

767
00:31:00,866 --> 00:31:01,866
到最後是

768
00:31:01,866 --> 00:31:04,833
不是左邊界右邊界的中間的那些

769
00:31:04,933 --> 00:31:06,700
even row的插補值

770
00:31:06,700 --> 00:31:09,633
你有寫對的話就用20分總共40

771
00:31:11,066 --> 00:31:12,800
那data level simulation的話

772
00:31:12,800 --> 00:31:15,066
就是我們是全對才給分

773
00:31:15,500 --> 00:31:18,466
所以就是如果你那個合成完的

774
00:31:18,500 --> 00:31:20,133
電路可以通過所有測試的話

775
00:31:20,133 --> 00:31:22,033
就是有20分這樣子

776
00:31:22,766 --> 00:31:26,300
那performance的話我們一樣是20分

777
00:31:26,333 --> 00:31:28,133
那我們那個performance

778
00:31:28,133 --> 00:31:29,700
看的標準是你的

779
00:31:29,900 --> 00:31:33,266
電路的成本跟是模擬的時間

780
00:31:33,400 --> 00:31:34,700
就是依照這公式

781
00:31:34,700 --> 00:31:38,233
前面這里也是你那個合成資源的數量

782
00:31:38,300 --> 00:31:42,166
然後乘上你的最長的模擬時間

783
00:31:42,166 --> 00:31:43,366
所以請大家模擬的時候

784
00:31:43,366 --> 00:31:45,100
不要用那個fast

785
00:31:45,100 --> 00:31:48,433
因為我們看的是最長模擬的時間

786
00:31:49,333 --> 00:31:52,400
那這個乘出來的值就是你們的scoring

787
00:31:52,533 --> 00:31:55,700
那score的越小就就會排序越前面

788
00:31:55,700 --> 00:31:57,966
然後到時候會再說繳交

789
00:31:57,966 --> 00:31:59,366
而且他有gate level

790
00:31:59,900 --> 00:32:03,600
完成的作業去做排序給分這樣子

791
00:32:03,600 --> 00:32:05,100
那這部分是20

792
00:32:05,400 --> 00:32:06,800
然後最後我們軟體驗證的時候

793
00:32:06,800 --> 00:32:08,200
一樣是20分

794
00:32:08,400 --> 00:32:10,933
那這邊我們測試的方法就是

795
00:32:10,933 --> 00:32:11,400
到時候

796
00:32:11,400 --> 00:32:14,566
都會用我們自己隱藏測試的圖片

797
00:32:14,733 --> 00:32:18,433
去輸入你們的那個軟體測試的程式

798
00:32:18,533 --> 00:32:20,766
做處理把它變成

799
00:32:20,766 --> 00:32:22,866
image.dat and golden.dat

800
00:32:22,933 --> 00:32:24,300
然後再用這兩筆

801
00:32:24,966 --> 00:32:27,833
助教的圖片生成的image.dat 還有

802
00:32:27,933 --> 00:32:30,166
golden.dat去驗證你的電路

803
00:32:30,166 --> 00:32:31,766
那如果可以pass的話

804
00:32:31,766 --> 00:32:34,633
就可以拿到這20分

805
00:32:35,466 --> 00:32:38,833
那所以請同學要確定你的電路就是

806
00:32:39,133 --> 00:32:42,566
不要針對特定一張圖片去寫就不要

807
00:32:42,800 --> 00:32:44,333
因為我們原本有附1組

808
00:32:44,333 --> 00:32:45,300
image.dat and golden.dat

809
00:32:46,000 --> 00:32:49,166
那就是請你不要針對這

810
00:32:49,400 --> 00:32:51,500
一組data去設計你的電路

811
00:32:51,500 --> 00:32:53,266
不然可能我到時候換一張

812
00:32:53,333 --> 00:32:54,633
不同的圖片

813
00:32:54,700 --> 00:32:55,666
你就過不了

814
00:32:55,666 --> 00:32:56,900
那這邊分數

815
00:32:56,900 --> 00:32:58,666
你沒辦法拿到

816
00:32:58,933 --> 00:33:01,333
然後還有就是請你自己

817
00:33:01,333 --> 00:33:04,266
寫完軟體code之後都是多生成幾組data

818
00:33:04,333 --> 00:33:06,833
去測試看看你的電路是不是都能過

819
00:33:06,866 --> 00:33:07,700
如果不能過

820
00:33:07,700 --> 00:33:10,600
可以想一下電路是不是有什麼

821
00:33:10,700 --> 00:33:12,933
在特定data情況下會發生bug

822
00:33:12,933 --> 00:33:14,900
這樣子 然後還有就是

823
00:33:14,900 --> 00:33:16,966
因為我們命名都是一樣

824
00:33:16,966 --> 00:33:18,966
命名就image.dat, golden.dat

825
00:33:19,333 --> 00:33:21,666
那都是請同學小心不要把

826
00:33:21,766 --> 00:33:24,466
原本提供的那一份蓋過

827
00:33:24,466 --> 00:33:26,333
因為我們除了軟體驗證以外

828
00:33:26,333 --> 00:33:27,766
前面的分數主要

829
00:33:27,766 --> 00:33:29,266
還是根據我們一開始提供

830
00:33:29,266 --> 00:33:31,900
那一份對他去做驗證的

831
00:33:33,200 --> 00:33:35,666
最後繳交的部分就是一樣

832
00:33:35,666 --> 00:33:38,700
那個請把你的資料

833
00:33:39,133 --> 00:33:41,200
.v放一個資料夾

834
00:33:41,366 --> 00:33:43,733
.v, .sdo放一個資料夾

835
00:33:43,733 --> 00:33:45,500
然後還有我們的那個report

836
00:33:45,500 --> 00:33:46,766
放一個資料夾

837
00:33:46,900 --> 00:33:48,966
那還有就是軟體code

838
00:33:49,300 --> 00:33:52,866
就是.c/.cpp

839
00:33:52,866 --> 00:33:54,066
然後.py

840
00:33:54,200 --> 00:33:56,533
那些還有你如果有readme的話

841
00:33:56,533 --> 00:33:58,500
就把全部放到一個資料夾

842
00:33:58,600 --> 00:34:00,566
最後四個資料夾一起壓縮

843
00:34:00,566 --> 00:34:04,166
然後命名成HW4_ID_name.zip

844
00:34:04,533 --> 00:34:06,600
請照格式

845
00:34:06,600 --> 00:34:09,700
就是請用zip壓縮

846
00:34:09,766 --> 00:34:11,600
然後前面命名也請依照規定

847
00:34:11,600 --> 00:34:13,566
不然就是會扣5分這樣

848
00:34:14,566 --> 00:34:16,800
那另外還還有要提醒

849
00:34:16,800 --> 00:34:19,066
就是請大家那個

850
00:34:19,166 --> 00:34:23,166
你壓縮完上傳就是請把它下載下來

851
00:34:23,266 --> 00:34:24,366
再驗證一次

852
00:34:24,366 --> 00:34:25,933
就是有很多同學都說

853
00:34:25,933 --> 00:34:28,066
什麼沒有存到最後一版

854
00:34:28,066 --> 00:34:31,400
不是他傳上去的時候不小心傳錯了

855
00:34:31,400 --> 00:34:33,266
那等到那我們的改作業

856
00:34:33,266 --> 00:34:35,666
他看到分數才發現為什麼和他想的

857
00:34:35,666 --> 00:34:36,600
不一樣

858
00:34:36,666 --> 00:34:38,500
那這樣其實我們也蠻難處理的

859
00:34:38,500 --> 00:34:41,300
所以所以請大家上傳到務必

860
00:34:41,700 --> 00:34:43,600
在下載驗證一下

861
00:34:43,600 --> 00:34:46,133
確定你傳的那一份是你要傳的

862
00:34:46,133 --> 00:34:47,366
正確答案

863
00:34:49,066 --> 00:34:50,866
哦然後在report file的部分

864
00:34:50,866 --> 00:34:52,466
就是請大家到Spec去寫

865
00:34:52,466 --> 00:34:54,566
就是要寫你的functional

866
00:34:54,566 --> 00:34:56,900
然後gate level是pass or fail

867
00:34:56,966 --> 00:34:58,833
然後要填你使用的

868
00:34:58,866 --> 00:35:00,800
這些什麼logic ELEMENTS

869
00:35:00,900 --> 00:35:03,666
photo memory bits然後9 beat element

870
00:35:03,866 --> 00:35:06,633
還有你的那個電路的模擬時間

871
00:35:06,800 --> 00:35:09,866
跟那個你的flow summerary也要貼上去

872
00:35:09,866 --> 00:35:11,866
然後大家到時候看一下那個

873
00:35:11,900 --> 00:35:12,966
report spec

874
00:35:12,966 --> 00:35:14,900
就照著寫就沒問題了

875
00:35:15,066 --> 00:35:17,066
那就是請大家就是

876
00:35:17,066 --> 00:35:19,300
該填的資料都填一填

877
00:35:21,166 --> 00:35:23,800
然後最後一個要注意的地方是

878
00:35:23,866 --> 00:35:27,133
因為我們這次的電路評分會跟

879
00:35:27,133 --> 00:35:29,666
會跟你的模擬時間有關

880
00:35:29,700 --> 00:35:32,566
所以我們這次開放大家可以去調

881
00:35:32,566 --> 00:35:35,300
TB的cycle跟end cycle

882
00:35:35,933 --> 00:35:39,200
那cycle指的是你的那個

883
00:35:39,300 --> 00:35:40,966
輸入clock的period

884
00:35:41,500 --> 00:35:42,500
就是cycle越小

885
00:35:42,500 --> 00:35:44,466
你的clock週期越短

886
00:35:44,500 --> 00:35:47,766
那你的電路跑的就會越快啊

887
00:35:47,766 --> 00:35:48,933
那end cycle

888
00:35:48,933 --> 00:35:51,833
是說你電路模擬最多可以花

889
00:35:51,866 --> 00:35:53,166
幾個cycle

890
00:35:53,400 --> 00:35:54,800
那這個就是你

891
00:35:54,800 --> 00:35:56,333
如果你的電路要跑比較久

892
00:35:56,333 --> 00:35:57,100
你就可以把它調

893
00:35:57,100 --> 00:35:58,033
大一點

894
00:35:59,200 --> 00:35:59,933
那

895
00:35:59,933 --> 00:36:02,266
cycle對你那個模擬時間影響就是

896
00:36:02,266 --> 00:36:03,300
假設你現在

897
00:36:03,400 --> 00:36:05,466
你的電路要跑1,000個cycle

898
00:36:05,466 --> 00:36:07,800
然後我cycle我原本是10

899
00:36:07,800 --> 00:36:09,666
那是10 ns

900
00:36:09,666 --> 00:36:11,966
那我最後就是花10乘以1,000

901
00:36:11,966 --> 00:36:13,600
是10000 ns

902
00:36:14,133 --> 00:36:16,400
那如果我今天我的cycle我調成5

903
00:36:16,400 --> 00:36:18,066
5ns

904
00:36:18,366 --> 00:36:20,266
那我同樣跑1,000個cycle

905
00:36:20,266 --> 00:36:21,466
那我就是5乘以1,000

906
00:36:21,466 --> 00:36:23,200
我只要5,000ns

907
00:36:23,200 --> 00:36:24,400
就可以跑完

908
00:36:24,466 --> 00:36:27,200
那我模擬時間就是變成原本的一半

909
00:36:27,200 --> 00:36:29,566
所以cycle就是大家可以盡量看你

910
00:36:29,566 --> 00:36:31,633
合成後可以跑到多快

911
00:36:32,000 --> 00:36:34,600
那我們模擬都是用合成後的code為主

912
00:36:34,600 --> 00:36:36,866
去做那個performance的驗證

913
00:36:37,466 --> 00:36:38,333
然後我們的

914
00:36:38,333 --> 00:36:41,200
作業極限是5月27的

915
00:36:41,333 --> 00:36:44,366
下午4:59 那就請同學

916
00:36:44,366 --> 00:36:46,066
不要壓到最後一刻才上傳

917
00:36:46,066 --> 00:36:49,900
然後說網絡卡住沒傳到

918
00:36:49,900 --> 00:36:51,900
就是盡量早一點上傳

919
00:36:51,900 --> 00:36:52,566
這樣

920
00:36:52,566 --> 00:36:55,800
他如果有問題就是寄到這個助教信箱

921
00:36:55,866 --> 00:36:59,066
如果有要到lab問問題可以先寄信

922
00:36:59,300 --> 00:37:01,066
跟這個助調約一下時間

923
00:37:01,066 --> 00:37:02,966
看他有沒有空這樣子

924
00:37:03,400 --> 00:37:05,166
那如果沒有問題就可以下課了

925
00:37:05,166 --> 00:37:06,166
謝謝大家

