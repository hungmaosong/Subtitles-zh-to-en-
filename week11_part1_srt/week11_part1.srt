1
00:00:00,133 --> 00:00:01,166
接下來

2
00:00:01,166 --> 00:00:03,266
我們從這邊開始

3
00:00:06,400 --> 00:00:08,233
在這章我們

4
00:00:09,800 --> 00:00:12,300
講過其實在這一章

5
00:00:12,300 --> 00:00:14,900
最主要是要講Datapath的optimization

6
00:00:14,900 --> 00:00:19,166
那我們大概分兩個部分來講

7
00:00:19,166 --> 00:00:23,100
今天至少要講完resource optimization

8
00:00:23,100 --> 00:00:26,700
就是說我今天要做最佳化

9
00:00:26,700 --> 00:00:28,966
datapath的最佳化

10
00:00:28,966 --> 00:00:31,900
那我們再回顧一下你的設計要跟

11
00:00:31,966 --> 00:00:34,266
Control path 跟 datapath

12
00:00:34,400 --> 00:00:36,800
也就是Controller跟datapath

13
00:00:37,133 --> 00:00:38,333
那你的Controller

14
00:00:38,333 --> 00:00:41,500
因為他有一個標準的寫法就是2C1S

15
00:00:41,533 --> 00:00:43,900
你只要根據你實際的題目

16
00:00:44,000 --> 00:00:46,233
畫出你所謂的state diagram

17
00:00:47,000 --> 00:00:48,166
就可以跟

18
00:00:48,333 --> 00:00:52,000
follow那個兩個組合電路一個

19
00:00:52,000 --> 00:00:55,500
register把你的Controller寫完

20
00:00:55,500 --> 00:00:58,400
那因為他有標準的寫法

21
00:00:58,400 --> 00:01:00,266
那datapath不一樣

22
00:01:00,266 --> 00:01:02,200
datapath我們上次已經講了

23
00:01:02,200 --> 00:01:05,100
他並沒有標準的寫法

24
00:01:05,100 --> 00:01:08,000
那你datapath要做最佳化的話呢

25
00:01:08,000 --> 00:01:10,333
你可以從兩個方向來看

26
00:01:10,333 --> 00:01:12,066
第一個當然我們知道

27
00:01:12,600 --> 00:01:15,200
所有的硬體大概最重要的兩件事呢

28
00:01:15,200 --> 00:01:17,100
第一個是成本的最佳化

29
00:01:17,100 --> 00:01:18,766
成本要越低越

30
00:01:18,766 --> 00:01:21,800
那第二個是速度要越快越

31
00:01:21,800 --> 00:01:23,933
所以呢第一個 resource optimization

32
00:01:23,933 --> 00:01:27,966
講的就是成本的最佳化

33
00:01:28,166 --> 00:01:30,300
這邊的resource講的是硬體的

34
00:01:30,300 --> 00:01:31,933
haadware的resource

35
00:01:31,933 --> 00:01:34,333
講的是你的硬體成分

36
00:01:34,333 --> 00:01:37,966
那我們有四個方式可以來做

37
00:01:37,966 --> 00:01:39,766
硬體成本的最佳化

38
00:01:39,766 --> 00:01:42,866
那第二個是timing的optimization

39
00:01:42,900 --> 00:01:44,200
我希望我跑的

40
00:01:44,200 --> 00:01:46,600
我這個電路跑的越快越

41
00:01:46,600 --> 00:01:49,866
那時間的最佳化我們這裡也是四個

42
00:01:50,466 --> 00:01:51,866
那

43
00:01:51,966 --> 00:01:54,100
我們上次其實結論有稍微

44
00:01:54,100 --> 00:01:55,466
提醒大加

45
00:01:55,533 --> 00:01:58,300
這個最佳化基本上timing optimizaton

46
00:01:58,466 --> 00:02:00,466
也許你可能是不怎麽做

47
00:02:00,500 --> 00:02:02,333
因為有時候你為了要讓

48
00:02:02,333 --> 00:02:04,400
你的電路速度夠快

49
00:02:04,400 --> 00:02:07,000
你必須一定要做timing

50
00:02:07,000 --> 00:02:09,266
timing 的 time的 optimizaton

51
00:02:09,500 --> 00:02:13,200
但是resource optimizaton通常不太會做

52
00:02:13,266 --> 00:02:13,600


53
00:02:13,600 --> 00:02:16,633
因為當Resource optimizaton一做下去

54
00:02:16,666 --> 00:02:20,100
你的電路一定是在gate level上去設計

55
00:02:20,100 --> 00:02:22,333
你沒有辦法太點對點去

56
00:02:22,333 --> 00:02:23,433
寫成你的電路

57
00:02:23,600 --> 00:02:25,233
我們等一下就會舉例

58
00:02:25,466 --> 00:02:27,166
舉例你就會知道說

59
00:02:27,166 --> 00:02:30,200
這個像不太不太方便

60
00:02:30,200 --> 00:02:32,700
因為你只要一用resource

61
00:02:32,700 --> 00:02:35,266
optimizaton這些方法一用下去

62
00:02:35,266 --> 00:02:37,466
你的電路保證必須要在gate level

63
00:02:38,300 --> 00:02:39,533
可是呢

64
00:02:39,533 --> 00:02:40,966
其實這些resource optimizaton

65
00:02:40,966 --> 00:02:43,100
又有一個處

66
00:02:43,133 --> 00:02:45,666
因為他節省了一些硬體成本

67
00:02:45,866 --> 00:02:47,400
所以對學術上

68
00:02:47,400 --> 00:02:50,866
我只能說他對學術上是還蠻有趣的

69
00:02:50,866 --> 00:02:53,300
對學術上有貢獻

70
00:02:53,300 --> 00:02:54,766
所學術上有貢獻

71
00:02:54,766 --> 00:02:57,066
就是說你設計了一個電路

72
00:02:57,133 --> 00:02:58,066
做某一件事

73
00:02:58,066 --> 00:03:00,533
那我今天可以做跟你一樣的事情

74
00:03:00,533 --> 00:03:03,000
可是我硬體成本少了一點點

75
00:03:03,066 --> 00:03:05,000
我少了你兩個加法

76
00:03:05,000 --> 00:03:06,966
我少了你幾個暫存器

77
00:03:06,966 --> 00:03:08,533
這就是一篇很的paper

78
00:03:08,533 --> 00:03:10,566
因為我確實成本比你低嘛

79
00:03:11,100 --> 00:03:14,533
所以在學術上他會有貢獻

80
00:03:14,533 --> 00:03:17,166
那學術上不會管你說你是用gate level

81
00:03:17,200 --> 00:03:19,333
或是你要用其他的方法

82
00:03:19,333 --> 00:03:22,900
可是你在實際操作上在公司上

83
00:03:22,900 --> 00:03:25,733
你為了要節省這一兩個暫存器

84
00:03:25,733 --> 00:03:28,366
然後你讓你的電路上gate level

85
00:03:28,566 --> 00:03:29,766
不管是debug

86
00:03:29,766 --> 00:03:31,266
或者是說你在撰寫

87
00:03:31,266 --> 00:03:33,400
的時間都會拉的很長

88
00:03:33,466 --> 00:03:35,200
可能就沒有必要

89
00:03:35,733 --> 00:03:37,300
但是我們還是會把他講過

90
00:03:37,300 --> 00:03:38,933
我們就要說resource optimization

91
00:03:38,933 --> 00:03:41,433
個人認為沒有那麽重要

92
00:03:41,500 --> 00:03:43,266
但是可以讓你做入門

93
00:03:43,766 --> 00:03:45,600
做入門上是有重要

94
00:03:45,600 --> 00:03:47,433
但你實際上

95
00:03:47,600 --> 00:03:50,533
你去公司可能沒那麽重要

96
00:03:50,533 --> 00:03:53,300
那反倒是timing optimization

97
00:03:53,300 --> 00:03:54,766
這個是你必須要考慮的

98
00:03:54,766 --> 00:03:57,166
因為你去公公司工作的時候

99
00:03:57,166 --> 00:03:59,566
你會不得不需要做timing optimizaion

100
00:03:59,700 --> 00:04:00,466


101
00:04:00,466 --> 00:04:03,166
因為只有timing optimizaion可以

102
00:04:03,366 --> 00:04:05,900
把你的速度變快

103
00:04:07,000 --> 00:04:09,433
那接下來呢

104
00:04:09,533 --> 00:04:13,366
下一個我要舉的我們上次講的是

105
00:04:14,600 --> 00:04:18,300
這8件事情8個optimizaion呢

106
00:04:18,300 --> 00:04:20,566
我們會用一個例子串起來

107
00:04:20,566 --> 00:04:22,866
那我們用的例子是

108
00:04:24,800 --> 00:04:26,466
SRA optimizaion

109
00:04:26,466 --> 00:04:28,133
所謂square root

110
00:04:28,133 --> 00:04:29,866
optimizaion就是說

111
00:04:29,900 --> 00:04:33,400
假設我今天想要計算開根號

112
00:04:33,400 --> 00:04:36,966
就是根號a平方加b平方

113
00:04:37,100 --> 00:04:39,733
a平方加b平方之後開根號

114
00:04:39,733 --> 00:04:41,833
我想要計算這件事情

115
00:04:42,133 --> 00:04:45,066
跟他a平方加b平方

116
00:04:45,133 --> 00:04:47,066
那我怎麽算呢

117
00:04:47,066 --> 00:04:48,766
我要做一個電路

118
00:04:48,766 --> 00:04:51,366
你現在不是寫一個程式

119
00:04:51,366 --> 00:04:54,300
而是你要做一個電路來實現這

120
00:04:54,366 --> 00:04:55,766
這這個動作

121
00:04:55,766 --> 00:04:58,533
a平方加b平方開根號

122
00:04:58,533 --> 00:05:01,400
那我們上次提到說有一個數學加

123
00:05:01,400 --> 00:05:03,366
他很想一個近似的式子

124
00:05:03,366 --> 00:05:05,166
所以你可以看到他是近

125
00:05:05,766 --> 00:05:09,800
根號a平方加b平方

126
00:05:10,066 --> 00:05:13,533
可以近似成這一個

127
00:05:13,533 --> 00:05:16,166
你用這個式子可以來近似

128
00:05:16,166 --> 00:05:19,600
那這個式子呢是0.875X

129
00:05:20,000 --> 00:05:22,266
加0.5Y

130
00:05:22,266 --> 00:05:24,133
這兩個加起來的結果

131
00:05:24,133 --> 00:05:27,633
這是0.875X加0.5Y

132
00:05:27,733 --> 00:05:28,966
那還有一個x

133
00:05:29,300 --> 00:05:33,400
這兩個人里面的最大值

134
00:05:33,400 --> 00:05:35,733
那x y是什麽

135
00:05:35,733 --> 00:05:37,333
x y分別是a

136
00:05:37,333 --> 00:05:39,333
絕對值就是你的輸入

137
00:05:39,333 --> 00:05:43,100
a跟b的絕對值里面的比較大的是x

138
00:05:43,500 --> 00:05:47,166
a跟b絕對值里面比較小的是y

139
00:05:47,166 --> 00:05:49,333
然後呢你把它帶到這個式子里面

140
00:05:49,333 --> 00:05:50,966
就可以算出

141
00:05:50,966 --> 00:05:52,600
他得到了結果

142
00:05:52,700 --> 00:05:56,100
這個是得到結果就是逼近於根號的

143
00:05:56,100 --> 00:05:59,300
a平方加b平方

144
00:05:59,500 --> 00:06:00,866
那這個是我們

145
00:06:01,766 --> 00:06:02,500


146
00:06:02,500 --> 00:06:05,766
這邊有人提出來的那我們那我們的

147
00:06:05,766 --> 00:06:07,900
我們要算a平方加b平方

148
00:06:07,900 --> 00:06:11,200
就變成是計算右邊這個式子

149
00:06:11,200 --> 00:06:13,500
所以我們現在就是要算的是0.875x

150
00:06:13,500 --> 00:06:15,233
加0.5y

151
00:06:15,566 --> 00:06:16,866
然後還要算出x

152
00:06:17,100 --> 00:06:19,700
然後呢兩個人里面的最大值

153
00:06:19,700 --> 00:06:22,166
再求兩個人里面的

154
00:06:22,200 --> 00:06:23,400
比較大的

155
00:06:23,400 --> 00:06:24,466


156
00:06:25,466 --> 00:06:28,300


157
00:06:28,300 --> 00:06:30,400
那我們接下來就要開始了

158
00:06:30,533 --> 00:06:32,733
那我們有8個動作要做

159
00:06:32,733 --> 00:06:36,166
我們第一個要做的是storage的Sharing

160
00:06:36,333 --> 00:06:38,533
什麽叫storage的Sharing呢

161
00:06:38,533 --> 00:06:42,200
storage的Sharing就是儲存單元的共用

162
00:06:42,600 --> 00:06:43,966


163
00:06:43,966 --> 00:06:45,500
那首先呢

164
00:06:47,100 --> 00:06:50,266
我們來看Sharing這個字

165
00:06:50,266 --> 00:06:52,100
Sharing是共用

166
00:06:52,166 --> 00:06:53,333
那這個共用呢

167
00:06:53,333 --> 00:06:54,866
他其實跟那個

168
00:06:55,400 --> 00:06:59,000
一般我們在比如說你

169
00:06:59,000 --> 00:07:01,866
你如果在美國你要租租一間公寓

170
00:07:02,000 --> 00:07:03,266


171
00:07:04,366 --> 00:07:05,933
就會跟大加Share

172
00:07:05,933 --> 00:07:08,933
那這個Sharing有一個問題

173
00:07:08,933 --> 00:07:11,966
他的問題就是說像我們一般

174
00:07:11,966 --> 00:07:14,000
不像你在台灣的話

175
00:07:14,000 --> 00:07:16,700
你在台南你租房子大概分兩類

176
00:07:16,700 --> 00:07:18,233
第一個是單人套房

177
00:07:18,700 --> 00:07:21,733
你的套房里面就有房間跟廁所

178
00:07:21,733 --> 00:07:24,166
所以你的廁所是不用跟人加共用的

179
00:07:24,166 --> 00:07:25,566
不用Sharing

180
00:07:25,600 --> 00:07:27,266


181
00:07:28,000 --> 00:07:31,100
如果你是跟幾位同學一起去

182
00:07:31,100 --> 00:07:32,566
外面租了一層

183
00:07:32,566 --> 00:07:34,600
像公寓這樣的

184
00:07:34,600 --> 00:07:36,466
就是三間房或四間房

185
00:07:36,466 --> 00:07:38,233
或者是透天也沒有關系

186
00:07:38,266 --> 00:07:41,166
里面只有一個廁所或兩個廁所

187
00:07:41,200 --> 00:07:43,066
這個時候問題就會來了

188
00:07:43,066 --> 00:07:43,766
什麽問題

189
00:07:43,766 --> 00:07:44,566
Sharing

190
00:07:44,900 --> 00:07:48,600
就是說這個廁所是大加共用的

191
00:07:48,600 --> 00:07:51,500
也許三個同學共用一個廁所

192
00:07:51,800 --> 00:07:53,866
另外換句話說 a同學上廁所的時候

193
00:07:53,866 --> 00:07:55,300
b同學沒辦法上

194
00:07:55,333 --> 00:07:57,166
c同學也不能上

195
00:07:57,166 --> 00:07:59,400
一次只能有一個人上

196
00:07:59,400 --> 00:08:01,100
同樣的你的客廳

197
00:08:01,366 --> 00:08:03,933
或者是你的廚房也是Sharing的

198
00:08:03,933 --> 00:08:07,233
那就基本上就是大加共用的

199
00:08:07,266 --> 00:08:09,966
那這個儲存單元的共用

200
00:08:09,966 --> 00:08:12,166
什麽叫做儲存單元共用

201
00:08:12,400 --> 00:08:14,366
先強調一件事

202
00:08:14,366 --> 00:08:15,966
這個只要這個共用

203
00:08:15,966 --> 00:08:17,800
就會有一個問題是

204
00:08:17,800 --> 00:08:20,300
你用的時候我不能用 我用的時候你不能用

205
00:08:20,800 --> 00:08:22,800
因為我們共用了

206
00:08:22,800 --> 00:08:25,300
那基本上你也知道廁所

207
00:08:25,500 --> 00:08:27,166
你上了別人都不能上

208
00:08:27,166 --> 00:08:29,000
我上了你也不能上

209
00:08:29,000 --> 00:08:31,666
所以說的是storage的Sharing

210
00:08:31,666 --> 00:08:33,766
第一個概念就是被人用了

211
00:08:33,766 --> 00:08:35,500
你就不能用

212
00:08:35,500 --> 00:08:36,700
那同樣的道理

213
00:08:36,700 --> 00:08:40,066
我今天儲存單元什麽叫做被人用呢

214
00:08:40,066 --> 00:08:40,966
就不能用呢

215
00:08:40,966 --> 00:08:43,700
比如說我現在有一個儲存單元

216
00:08:43,700 --> 00:08:45,266
那我這里有3位同學

217
00:08:45,266 --> 00:08:47,233
要共用這個儲存單元

218
00:08:47,466 --> 00:08:49,466
那我這個儲存單元如果除了

219
00:08:49,500 --> 00:08:51,166
存了a同學的東西

220
00:08:51,166 --> 00:08:53,766
那b同學跟c同學就不能用

221
00:08:54,466 --> 00:08:56,300
因為如果b同學也要用

222
00:08:56,300 --> 00:08:58,200
那就又把他的東西存進來

223
00:08:58,200 --> 00:09:01,600
那b同學會蓋掉a同學的

224
00:09:01,600 --> 00:09:03,166
因為你是儲存共用

225
00:09:03,166 --> 00:09:04,500
所謂共用的意思

226
00:09:04,500 --> 00:09:06,900
我今天只有一個空間

227
00:09:07,466 --> 00:09:08,766
那a同學用的

228
00:09:08,766 --> 00:09:11,100
b同學就沒辦法用 b同學用的

229
00:09:11,100 --> 00:09:13,900
a同學的資料就不見了

230
00:09:13,900 --> 00:09:15,800
所以這個儲存單元共用

231
00:09:15,800 --> 00:09:18,266
只有發生在那些資料

232
00:09:18,666 --> 00:09:21,000
可以被蓋掉的情況 就是說

233
00:09:21,000 --> 00:09:23,366
不然的話因為它是共用

234
00:09:23,366 --> 00:09:25,100
所以我們來看一下

235
00:09:25,133 --> 00:09:26,966
這個storage的Sharing呢

236
00:09:26,966 --> 00:09:29,433
比如說我們來看這個數學式子

237
00:09:29,800 --> 00:09:32,066
假設呢我的...

238
00:09:32,066 --> 00:09:33,800
你把它想象成我有一個軟體

239
00:09:33,800 --> 00:09:35,666
程式要算

240
00:09:35,666 --> 00:09:37,000
x=a+1

241
00:09:37,000 --> 00:09:39,900
我要把a+1的結果放到x

242
00:09:39,900 --> 00:09:41,900


243
00:09:41,900 --> 00:09:44,066
那這是我在上面要做的事情

244
00:09:44,066 --> 00:09:46,966
然後等等等等我要繼續往下做

245
00:09:46,966 --> 00:09:50,266
做到後面我又要算y=c+d

246
00:09:50,266 --> 00:09:51,700
我要把c+d

247
00:09:51,700 --> 00:09:53,066
結果放到y

248
00:09:53,566 --> 00:09:55,100


249
00:09:55,100 --> 00:09:57,933
那這個這個是你要做這這兩個狀態

250
00:09:57,933 --> 00:10:00,200
左邊這個看得出來

251
00:10:00,600 --> 00:10:02,233


252
00:10:02,333 --> 00:10:05,066
那正常的情況是這樣

253
00:10:05,066 --> 00:10:07,533
我要有一個暫存器

254
00:10:07,533 --> 00:10:09,366
我要存x

255
00:10:09,366 --> 00:10:12,266
因為a+b的結果要存到x

256
00:10:12,266 --> 00:10:15,000
所以我要一個儲存空間

257
00:10:15,000 --> 00:10:17,066
那這個儲存空間就是我們前面講的

258
00:10:17,066 --> 00:10:21,066
register 你可能要有一個32位元的register

259
00:10:21,133 --> 00:10:23,833
或64位元的register來存x

260
00:10:24,666 --> 00:10:27,033
那同樣的你也要一個register

261
00:10:27,166 --> 00:10:28,566
來存y

262
00:10:28,566 --> 00:10:31,200
因為你要把a加b的結果放到x

263
00:10:31,333 --> 00:10:35,166
把c加d的結果放到y

264
00:10:35,166 --> 00:10:38,000
所以你x需要一個暫存器

265
00:10:38,000 --> 00:10:40,966
那你y也需要一個暫存器

266
00:10:40,966 --> 00:10:43,900
那你如果完全沒有做shring

267
00:10:43,900 --> 00:10:46,800
就像中間這張圖的意思

268
00:10:46,800 --> 00:10:49,500
因為底下有一個加法

269
00:10:49,500 --> 00:10:53,100
所以呢就是這邊一開始

270
00:10:53,500 --> 00:10:55,900
選擇器

271
00:10:55,900 --> 00:10:57,133
多工器

272
00:10:57,133 --> 00:10:58,900
選擇器往這里選擇a下來

273
00:10:58,900 --> 00:11:01,533
然後這邊選擇b下來

274
00:11:01,533 --> 00:11:02,866
他這里有一個加法器

275
00:11:02,866 --> 00:11:04,366
他會幫你做a加b

276
00:11:05,066 --> 00:11:05,900
加法的結果

277
00:11:05,900 --> 00:11:08,966
你把他存到x去

278
00:11:09,200 --> 00:11:10,900
那就可以做完這一件事

279
00:11:10,900 --> 00:11:13,166
x=a+b

280
00:11:13,166 --> 00:11:15,600
等到你過了幾個狀態

281
00:11:15,600 --> 00:11:17,433
你接下來要做c加d

282
00:11:18,066 --> 00:11:21,400
放到y那你就是選擇器這邊選c

283
00:11:22,166 --> 00:11:24,233
選擇器這邊選d

284
00:11:24,400 --> 00:11:26,600
然後經過這個加法加完之後

285
00:11:26,600 --> 00:11:28,700
結果存到y

286
00:11:29,266 --> 00:11:31,800
c+d存到y

287
00:11:31,800 --> 00:11:33,933
所以呢你其實用了兩個

288
00:11:33,933 --> 00:11:37,200
儲存單元一個存x一個存y

289
00:11:37,200 --> 00:11:38,233
看得出來

290
00:11:38,266 --> 00:11:39,766
你有兩個儲存單元

291
00:11:39,766 --> 00:11:40,833
一個存x

292
00:11:41,000 --> 00:11:43,100
一個存y

293
00:11:43,800 --> 00:11:45,700
這個是沒有sharing

294
00:11:45,700 --> 00:11:46,400
那你看一下

295
00:11:46,400 --> 00:11:48,466
再看一下我們的題目叫

296
00:11:48,466 --> 00:11:51,166
storage sharing就是共享

297
00:11:51,200 --> 00:11:53,333
那什麽時候可以共享呢

298
00:11:53,333 --> 00:11:54,566
重點來了對

299
00:11:54,566 --> 00:11:55,533
這也是很重要

300
00:11:55,533 --> 00:11:57,833
因為我剛前面已經點題了

301
00:11:57,900 --> 00:12:00,366
所以共享就是你用的時候我不能用

302
00:12:00,366 --> 00:12:02,100
我用的時候你不能用嘛

303
00:12:02,100 --> 00:12:04,200
對不對然後呢

304
00:12:05,400 --> 00:12:06,766
我們x,y

305
00:12:06,766 --> 00:12:09,100
可不可以共享一個儲存空間

306
00:12:09,366 --> 00:12:10,300


307
00:12:10,366 --> 00:12:12,700
我只有一個儲存空間

308
00:12:12,700 --> 00:12:13,966
你原來要兩個

309
00:12:15,000 --> 00:12:18,166
那我們會用一個儲存空間存x

310
00:12:18,166 --> 00:12:19,166
又存y

311
00:12:19,866 --> 00:12:21,866
那什麽時候可以存x

312
00:12:22,166 --> 00:12:24,400
又可以存y呢

313
00:12:24,600 --> 00:12:25,866
他前提在這里

314
00:12:25,866 --> 00:12:27,266
如果說你看你你

315
00:12:27,266 --> 00:12:29,266
你想象一下我a加b

316
00:12:29,566 --> 00:12:31,666
之後算出x

317
00:12:32,133 --> 00:12:33,033
那這個x

318
00:12:33,700 --> 00:12:34,966
我需要一個儲存空間

319
00:12:34,966 --> 00:12:37,900
那我就存在一個program

320
00:12:37,900 --> 00:12:38,933
那如果x呢

321
00:12:38,933 --> 00:12:40,200
值被用完了

322
00:12:40,200 --> 00:12:42,600
以後沒有人會再用x

323
00:12:42,900 --> 00:12:44,866
對不對我就可以把y

324
00:12:45,200 --> 00:12:48,266
也存到x上的空間去

325
00:12:48,266 --> 00:12:50,166
但是他的前提在

326
00:12:50,500 --> 00:12:54,000
因為別人用了你的就不見了

327
00:12:54,000 --> 00:12:57,366
所以這個共享的概念就是說

328
00:12:57,366 --> 00:12:59,333
你用了我就不能用了

329
00:12:59,333 --> 00:13:03,566
那我儲存空間假設我存了我的值

330
00:13:03,566 --> 00:13:06,266
那有一天我跟跟你說

331
00:13:06,266 --> 00:13:07,300
你也可以存在這里

332
00:13:07,300 --> 00:13:10,266
你一存過來我的值就不見了

333
00:13:10,266 --> 00:13:13,500
所以如果你在這邊算完x之後

334
00:13:13,500 --> 00:13:15,966
在這個狀態的時候呢

335
00:13:15,966 --> 00:13:18,433
在下面又過了好幾個狀態

336
00:13:18,466 --> 00:13:20,300
這個時候不會再用到x

337
00:13:20,366 --> 00:13:23,266
我就可以把c+d的結果存到

338
00:13:23,600 --> 00:13:27,000
這個y這個我可以用同樣一個空間

339
00:13:27,733 --> 00:13:29,666
這個叫做register sharing

340
00:13:29,900 --> 00:13:30,366
所以

341
00:13:30,366 --> 00:13:33,166
他只有在什麽時候可以這樣做呢

342
00:13:33,666 --> 00:13:36,500
x跟y的生命

343
00:13:36,500 --> 00:13:37,700
什麽叫生命期

344
00:13:37,700 --> 00:13:40,600
就是說我這里要算出來x

345
00:13:40,600 --> 00:13:42,400
我x要一直記得

346
00:13:42,933 --> 00:13:43,266
對不對

347
00:13:43,266 --> 00:13:45,566
但是我這里可能會一直用x

348
00:13:45,566 --> 00:13:48,133
那沒關系 我一直有記住x

349
00:13:48,133 --> 00:13:50,266
我想到要用的時候就可以用

350
00:13:50,533 --> 00:13:52,966
可是當我今天要產生y

351
00:13:52,966 --> 00:13:54,300
要存過去的時候

352
00:13:54,300 --> 00:13:57,000
假設我後面已經不會再用到x

353
00:13:57,000 --> 00:13:59,366
我就可以把x

354
00:13:59,366 --> 00:14:02,433
這個暫存的空間釋放出來

355
00:14:02,500 --> 00:14:03,500
來存y

356
00:14:03,500 --> 00:14:06,466
因為兩個人的生命期沒有重疊

357
00:14:06,966 --> 00:14:08,400
沒有重疊

358
00:14:08,400 --> 00:14:10,733
所以這個叫做暫存器的共用

359
00:14:10,733 --> 00:14:14,133
那我們怎麽做呢

360
00:14:14,133 --> 00:14:15,400
其實舉這個例子

361
00:14:15,400 --> 00:14:17,933
會比我剛剛在面講半天還來的快

362
00:14:17,933 --> 00:14:19,566
給你30秒

363
00:14:19,566 --> 00:14:22,033
你先把剛剛那個開根號那個

364
00:14:22,100 --> 00:14:23,866
例子再看一次好不好

365
00:14:41,300 --> 00:14:44,066
我們來看一下

366
00:14:44,066 --> 00:14:47,700
一個是根號a平方加b平方

367
00:14:47,700 --> 00:14:49,400
那我們剛剛已經

368
00:14:49,400 --> 00:14:52,200
再幫你復習了 你就是算0.875x

369
00:14:52,466 --> 00:14:54,300
加上0.5Y

370
00:14:54,300 --> 00:14:54,900
還有x

371
00:14:54,900 --> 00:14:57,700
求兩個人里面的最大

372
00:14:58,300 --> 00:15:00,100
那你的XY呢

373
00:15:00,133 --> 00:15:00,400


374
00:15:00,400 --> 00:15:04,300
你把AB各別求絕對值比較大的就是x

375
00:15:04,400 --> 00:15:08,533
AB各別求絕對值比較小的就是y

376
00:15:08,533 --> 00:15:11,300
這個是我們前面的理解

377
00:15:11,333 --> 00:15:13,233
那再看一下

378
00:15:13,466 --> 00:15:15,600
你的電路設計的時候要分controller

379
00:15:15,600 --> 00:15:16,466
跟datapath

380
00:15:16,466 --> 00:15:18,900
那controller的我們就不再講了

381
00:15:18,900 --> 00:15:21,533
因為controller的就是你set畫出來之後

382
00:15:21,533 --> 00:15:22,333
2C1S

383
00:15:22,866 --> 00:15:25,433
但是帶他datapath就要有經驗了

384
00:15:25,466 --> 00:15:27,000
你要怎麽設計

385
00:15:27,000 --> 00:15:29,500
才會是一個完整的datapath

386
00:15:29,500 --> 00:15:32,400
所以我們現在講的是這個datapath的部分

387
00:15:32,466 --> 00:15:36,266
那如果你要考慮Register Sharing

388
00:15:36,266 --> 00:15:40,333
那我們來看大概你要做1234 

389
00:15:40,333 --> 00:15:43,466
那在檢查這四個步驟的時候

390
00:15:43,466 --> 00:15:47,366
我們先再把這個流程走過一次

391
00:15:47,600 --> 00:15:50,700
一開始你要讀進來放到a

392
00:15:50,700 --> 00:15:52,133
第一個輸入讀到a

393
00:15:52,133 --> 00:15:52,866
第二個讀到b

394
00:15:52,866 --> 00:15:55,733
因為你要算根號a平方加b平方

395
00:15:55,733 --> 00:15:56,700
對不對

396
00:15:56,700 --> 00:15:59,766
你要算根號a平方加b平方

397
00:15:59,766 --> 00:16:02,100
所以呢幹嘛你要把

398
00:16:03,166 --> 00:16:04,933
假設你有兩個輸入

399
00:16:04,933 --> 00:16:07,133
那你把第一個輸入讀進來放到a

400
00:16:07,133 --> 00:16:09,966
第二個輸入讀進來放到b

401
00:16:10,066 --> 00:16:12,200
接下來我發出了一個啟動訊號

402
00:16:12,200 --> 00:16:14,300
代表我要開始做了

403
00:16:14,300 --> 00:16:16,666
那我一開始做 我會先求什麽

404
00:16:17,066 --> 00:16:19,266
a的絕對值跟b的絕對值

405
00:16:19,266 --> 00:16:22,733
假設我一個狀態做一個動作

406
00:16:22,733 --> 00:16:25,700
所以我現在a b的值通通讀進來了

407
00:16:25,700 --> 00:16:30,033
所以我a的絕對值放到t1

408
00:16:30,133 --> 00:16:31,566
b的絕對值放到t2

409
00:16:31,566 --> 00:16:32,966
因為我要先算這個

410
00:16:32,966 --> 00:16:35,766
a的絕對值b的絕對值

411
00:16:36,400 --> 00:16:39,200
在這里我們要跟前面兜在一起

412
00:16:39,300 --> 00:16:41,800
這件事情你這個狀態

413
00:16:42,100 --> 00:16:43,066
你做兩件事

414
00:16:43,066 --> 00:16:45,900
這兩個動作是同步做

415
00:16:45,933 --> 00:16:46,966
那我問大加

416
00:16:46,966 --> 00:16:49,766
你可不可以說 我先做t1再做t2

417
00:16:49,766 --> 00:16:52,933
分兩種狀態 可以哦

418
00:16:52,933 --> 00:16:55,700
你要一個狀態同時算t1

419
00:16:55,700 --> 00:16:58,066
也同時算t2 這可以

420
00:16:58,066 --> 00:16:59,366
這邊的意思是這樣

421
00:16:59,366 --> 00:17:01,500
我在這個狀態同時算t1

422
00:17:01,500 --> 00:17:02,900
同時算t2

423
00:17:03,666 --> 00:17:05,500
那我也可以怎樣

424
00:17:05,500 --> 00:17:08,200
我也可以分兩個狀態

425
00:17:08,200 --> 00:17:09,966
第一個狀態算t1

426
00:17:10,166 --> 00:17:12,400


427
00:17:12,400 --> 00:17:14,800
第二個狀態算t2

428
00:17:14,800 --> 00:17:17,066
所以你這邊要一個state或兩個state

429
00:17:17,500 --> 00:17:19,233
是你的規劃

430
00:17:19,366 --> 00:17:20,466
你規劃的不一樣

431
00:17:20,466 --> 00:17:23,133
你整個電路都會不一樣

432
00:17:23,133 --> 00:17:24,700
那他的成本在哪里

433
00:17:24,700 --> 00:17:27,100
你要你要去你要去思考這件事

434
00:17:27,100 --> 00:17:28,900
因為我們整個一直在教

435
00:17:28,900 --> 00:17:30,066
你想的就是這個

436
00:17:30,066 --> 00:17:31,066
比如說你看

437
00:17:31,100 --> 00:17:33,166
當你這樣子寫你這個狀態

438
00:17:33,266 --> 00:17:34,900
同時算t1

439
00:17:34,900 --> 00:17:36,333
同時算t2

440
00:17:36,333 --> 00:17:36,966
對不對

441
00:17:36,966 --> 00:17:40,400
那代表你要你要幾個絕對值得硬體

442
00:17:40,600 --> 00:17:42,633
你要有同時要兩個

443
00:17:42,700 --> 00:17:45,300
因為你在對a做絕對值的時候

444
00:17:45,300 --> 00:17:47,666
你同時在對b做絕對值

445
00:17:47,800 --> 00:17:51,266
對不對 所以你至少要有兩個硬體

446
00:17:51,366 --> 00:17:54,100
兩個絕對值的硬體在對a做的時候

447
00:17:54,100 --> 00:17:55,500
你同時在對b做

448
00:17:55,500 --> 00:17:57,666
因為這兩個是同一個時間

449
00:17:58,133 --> 00:18:00,400
那如果你是分兩個狀態

450
00:18:00,400 --> 00:18:04,733
比如說你是第一個狀態先算t1

451
00:18:04,733 --> 00:18:06,066
第二狀態算t2

452
00:18:06,066 --> 00:18:08,266
那這個時候你只需要一個絕對值的硬體

453
00:18:08,266 --> 00:18:09,500


454
00:18:09,500 --> 00:18:11,800
你可以用同一個絕對值的硬體

455
00:18:11,933 --> 00:18:13,866
來做a的絕對值

456
00:18:13,866 --> 00:18:17,166
那下一個狀態再去做b的絕對值

457
00:18:17,166 --> 00:18:18,000
所以

458
00:18:18,133 --> 00:18:20,900
你到底要不要放在同一個狀態

459
00:18:20,900 --> 00:18:22,466
這是看你的規劃

460
00:18:22,500 --> 00:18:23,700
你規劃的不一樣

461
00:18:23,700 --> 00:18:25,900
你的整個電路設計狀態處李

462
00:18:25,900 --> 00:18:27,633
通通會不一樣

463
00:18:28,166 --> 00:18:30,266
我這里先

464
00:18:30,600 --> 00:18:32,166
強調這件事

465
00:18:32,166 --> 00:18:34,200
所以到底是怎樣才對

466
00:18:34,200 --> 00:18:35,700
這個沒有標準答案給你

467
00:18:35,700 --> 00:18:37,300
你自己要去評估

468
00:18:37,300 --> 00:18:39,800
你自己要去評估 都對

469
00:18:39,800 --> 00:18:41,800
因為你這真的可以分一個狀態

470
00:18:41,800 --> 00:18:42,866
可以分兩個狀態看

471
00:18:42,866 --> 00:18:45,266
你是要成本低還是要速度快嘛

472
00:18:45,266 --> 00:18:46,133
就是這樣

473
00:18:46,133 --> 00:18:47,133


474
00:18:47,133 --> 00:18:49,766
那你算出t1,t2之後你幹嘛

475
00:18:50,066 --> 00:18:52,400
你要求x跟y

476
00:18:52,400 --> 00:18:53,266
所以你看

477
00:18:53,400 --> 00:18:56,666
t1,t2里面的最大值就是x

478
00:18:56,966 --> 00:18:57,933


479
00:18:57,933 --> 00:18:59,766
因為t1,t2其實已經是a

480
00:18:59,766 --> 00:19:01,066
b的絕對值了吧

481
00:19:01,066 --> 00:19:03,133
對不對 a的絕對值跟b的絕對值

482
00:19:03,133 --> 00:19:05,533
所以t1,t2里面比較小的值

483
00:19:05,533 --> 00:19:07,166
放到y去

484
00:19:07,166 --> 00:19:08,566
到這里沒有問題

485
00:19:08,566 --> 00:19:12,466
你就求出了這邊的x跟y

486
00:19:12,466 --> 00:19:13,866
那下一個狀態

487
00:19:14,066 --> 00:19:16,900
你把x右移右移3位

488
00:19:17,466 --> 00:19:20,133
y右移一位放到t

489
00:19:20,133 --> 00:19:21,733
y右移一位放到t4

490
00:19:21,733 --> 00:19:23,033
那代表什麽意思

491
00:19:23,266 --> 00:19:25,400
T4等於什麽0.5 y嘛

492
00:19:25,400 --> 00:19:27,666
因為你把y右移一位嘛

493
00:19:28,866 --> 00:19:32,533
那你x右移三位放到T3

494
00:19:32,533 --> 00:19:33,766
那代表什麽意思

495
00:19:33,766 --> 00:19:39,600
T3就是0.125x 因為右移一位變0.5

496
00:19:39,600 --> 00:19:41,466
右移兩位變0.25

497
00:19:41,466 --> 00:19:44,366
右移三位就變成0.125

498
00:19:44,500 --> 00:19:47,800
所以這邊T3其實是0.125x

499
00:19:47,966 --> 00:19:50,266
那T4其實是0.5Y

500
00:19:50,900 --> 00:19:53,800
所以你已經算出了這個0.5Y

501
00:19:54,600 --> 00:19:56,066
那你接下來要做什麽

502
00:19:56,066 --> 00:19:58,533
你要把x減掉T3為什麽

503
00:19:58,533 --> 00:20:02,300
因為T3是0.125X

504
00:20:02,400 --> 00:20:06,800
x減掉0.125X就會得到0.875X

505
00:20:07,133 --> 00:20:10,900
所以這個動作是算出0.875X

506
00:20:12,100 --> 00:20:12,933


507
00:20:12,933 --> 00:20:14,166
那接下來呢

508
00:20:14,200 --> 00:20:15,900
你要把這兩個相加

509
00:20:15,900 --> 00:20:20,300
所以你的T4或其實是0.5Y

510
00:20:20,366 --> 00:20:25,766
對不對那你的T5 T5是0.875x

511
00:20:25,766 --> 00:20:28,800
0.5Y加上0.875x

512
00:20:28,800 --> 00:20:30,266
結果放到T6去

513
00:20:30,266 --> 00:20:32,966
那這個T6就得到前面的這一個

514
00:20:32,966 --> 00:20:35,333
這這兩個的和

515
00:20:35,333 --> 00:20:36,200
那t6

516
00:20:36,200 --> 00:20:39,000
再跟x求里面的最大值

517
00:20:39,000 --> 00:20:40,566
放到t7 

518
00:20:40,566 --> 00:20:42,300
那就這樣就做完了

519
00:20:42,466 --> 00:20:44,900
那在這里我再講一次

520
00:20:44,900 --> 00:20:46,500
再強調一次

521
00:20:47,533 --> 00:20:48,466
你到底

522
00:20:48,533 --> 00:20:50,566
這兩個動作要在同一個狀態做

523
00:20:50,566 --> 00:20:52,733
還是分兩個狀態

524
00:20:52,733 --> 00:20:54,233
這個是你的規劃

525
00:20:54,766 --> 00:20:56,133
所以你也可以

526
00:20:56,133 --> 00:20:59,200
舉個例子我也可以把T4跟T5

527
00:20:59,466 --> 00:21:00,966
放在同一個狀態里面

528
00:21:00,966 --> 00:21:02,366
就我不要分兩個狀態

529
00:21:02,366 --> 00:21:03,766
我叫做T4

530
00:21:03,800 --> 00:21:06,233
那我T4同時做減法

531
00:21:06,400 --> 00:21:07,966
也同時做加法

532
00:21:08,400 --> 00:21:09,600
哦這樣也可以

533
00:21:09,600 --> 00:21:11,766
也沒有人說不行

534
00:21:11,766 --> 00:21:14,000
只是你的成本就會變高

535
00:21:14,000 --> 00:21:14,800
所以

536
00:21:14,866 --> 00:21:19,700
你這里到底要分S0到S7八個狀態

537
00:21:19,700 --> 00:21:21,666
還是要分9個 還是要分5個

538
00:21:21,666 --> 00:21:23,166
這個你可以做規劃

539
00:21:23,166 --> 00:21:24,566
但是你規劃的不一樣

540
00:21:24,566 --> 00:21:26,100
你的電路就不一樣

541
00:21:26,266 --> 00:21:28,000
只是這樣跟你講

542
00:21:28,000 --> 00:21:28,933
所以這個

543
00:21:28,933 --> 00:21:30,933
你哪幾個動作要分在同一個狀態

544
00:21:30,933 --> 00:21:33,166
這個你可以去分

545
00:21:33,166 --> 00:21:34,933
那接下來假設

546
00:21:34,933 --> 00:21:36,400
所以我們的前提就

547
00:21:36,400 --> 00:21:38,866
假設你是用左邊這樣

548
00:21:39,066 --> 00:21:42,000
這樣8個狀態的方法假設

549
00:21:42,100 --> 00:21:43,800
這個方法我覺得最簡單

550
00:21:43,800 --> 00:21:45,733
那我們就用這個方法

551
00:21:45,733 --> 00:21:46,800
沒有問題

552
00:21:46,900 --> 00:21:49,366
在這個方法的情況之下

553
00:21:49,366 --> 00:21:51,600
我怎麽做register的sharing

554
00:21:51,966 --> 00:21:55,500
因為我們現在要做storage的sharing

555
00:21:55,500 --> 00:21:56,733
那storage的sharing

556
00:21:56,733 --> 00:21:57,733
其實我們這邊

557
00:21:57,733 --> 00:22:00,666
講的主要就是暫存器的共用

558
00:22:00,666 --> 00:22:02,166
因為儲存空間

559
00:22:02,166 --> 00:22:03,266
那儲存空間

560
00:22:03,266 --> 00:22:06,333
其實我們這邊討論最多就是暫存器

561
00:22:06,333 --> 00:22:07,266
所以storage的sharing

562
00:22:07,566 --> 00:22:10,700
其實就是register的sharing

563
00:22:10,700 --> 00:22:13,066
那我們怎麽來做register的sharing呢

564
00:22:13,066 --> 00:22:13,966
就是這樣

565
00:22:14,266 --> 00:22:17,100
假設我已經知道我是分這8個狀態

566
00:22:17,100 --> 00:22:20,466
從S0到S7這8個狀態

567
00:22:20,466 --> 00:22:22,766
那我們要做register的sharing 我要幹嘛

568
00:22:23,166 --> 00:22:27,100
我首先要決定有幾個狀態

569
00:22:29,466 --> 00:22:31,133
這個我剛剛跟你講了

570
00:22:31,133 --> 00:22:32,266
這個就要看你

571
00:22:32,300 --> 00:22:36,400
你要分S0到S7 你也可以分S0到S9

572
00:22:36,400 --> 00:22:39,933
你也可以分S0到S4都可以

573
00:22:39,933 --> 00:22:42,333
你要4步做完5步做完6步做完

574
00:22:42,333 --> 00:22:44,166
你要12步做完都可以

575
00:22:44,166 --> 00:22:46,500
那電路就可能會不一樣

576
00:22:46,500 --> 00:22:48,133
所以第一個你要決定的是

577
00:22:48,133 --> 00:22:49,766
你要分幾個狀態

578
00:22:50,200 --> 00:22:51,400
那有了狀態之後

579
00:22:51,400 --> 00:22:55,466
你要決定每個變數的生命期

580
00:22:55,466 --> 00:22:57,266
因為我們剛剛已經講了

581
00:22:57,266 --> 00:22:58,600
你可以共用

582
00:22:58,600 --> 00:23:00,866
只有在我們的生命期

583
00:23:01,266 --> 00:23:02,200
沒有重疊

584
00:23:02,200 --> 00:23:03,233
換句話說

585
00:23:03,266 --> 00:23:04,800
你用的時候我不會用

586
00:23:04,800 --> 00:23:06,100
我用的時候你不會用

587
00:23:06,100 --> 00:23:08,400
這樣我們兩個就可以共用

588
00:23:08,400 --> 00:23:11,000
我們可以共用這個儲存空間的

589
00:23:11,000 --> 00:23:13,266
前提是我用的時候你不會用

590
00:23:13,266 --> 00:23:15,166
你用的時候我就不用了

591
00:23:15,166 --> 00:23:17,700
那這樣我們兩個就可以共用

592
00:23:17,700 --> 00:23:22,033
所以我們的生命期不能重疊

593
00:23:22,166 --> 00:23:25,266
那所以我要決定每個變數的生命期

594
00:23:25,466 --> 00:23:27,666
那每個變數的生命期決定出來

595
00:23:27,666 --> 00:23:28,600
我就可以知道

596
00:23:28,600 --> 00:23:31,300
我最少需要幾個暫存器

597
00:23:31,300 --> 00:23:33,700
那我就可以來設計這個電路

598
00:23:33,766 --> 00:23:35,466
那我們來看一下

599
00:23:35,466 --> 00:23:36,966
我們把這個串起來

600
00:23:36,966 --> 00:23:38,533
所以你可以看到

601
00:23:38,533 --> 00:23:41,300
從左邊這個狀態圖

602
00:23:41,300 --> 00:23:44,600
我就會畫出這個右邊的這個生命期

603
00:23:44,600 --> 00:23:46,600
每個變數生命期的

604
00:23:46,900 --> 00:23:48,366
示意圖

605
00:23:48,366 --> 00:23:50,066
那這個示意圖怎麼畫呢

606
00:23:50,066 --> 00:23:51,300
其實很簡單

607
00:23:51,300 --> 00:23:52,566
你注意看

608
00:23:53,700 --> 00:23:58,366
我S0這個狀態我把a b讀進來嘛

609
00:23:58,366 --> 00:24:00,266
我把第一個變數讀進來

610
00:24:00,266 --> 00:24:02,066
第一個輸入讀進來放到a

611
00:24:02,066 --> 00:24:04,000
第二個輸入讀進來放到b

612
00:24:04,000 --> 00:24:06,700
對不對那我問你a要活多久

613
00:24:06,700 --> 00:24:09,866
我們現在要求哪個變數的生命期

614
00:24:09,866 --> 00:24:11,433
A,B是一個變數

615
00:24:11,966 --> 00:24:13,300
那他要活多久

616
00:24:13,300 --> 00:24:15,733
生命期就是說

617
00:24:15,733 --> 00:24:17,066
我要活多久

618
00:24:17,300 --> 00:24:18,266
你注意看

619
00:24:18,266 --> 00:24:20,200
A,B被算出來之後

620
00:24:20,500 --> 00:24:23,433
A,B在這里被用掉了對不對

621
00:24:24,000 --> 00:24:26,233
後面還有沒有人用到我的a and b

622
00:24:26,533 --> 00:24:27,466
沒有

623
00:24:27,733 --> 00:24:31,266
所以我a b只要活一個狀態就了

624
00:24:31,266 --> 00:24:32,633
所以你看他是這樣

625
00:24:32,733 --> 00:24:35,366
a b只要在s1這個狀態活著

626
00:24:35,366 --> 00:24:36,866
因為你s

627
00:24:36,866 --> 00:24:38,100
你被算出來

628
00:24:38,100 --> 00:24:39,500
我在這里活著

629
00:24:40,100 --> 00:24:42,533
可以來算絕對值

630
00:24:42,533 --> 00:24:44,566
算完之後我AB可以丟掉了

631
00:24:44,566 --> 00:24:47,300
因為他不用再活著了

632
00:24:47,300 --> 00:24:50,666
所以這個叫做他的生命期

633
00:24:51,166 --> 00:24:53,000
算出t1,t2之後呢

634
00:24:53,000 --> 00:24:54,800
因為t1,t2算出來之後

635
00:24:54,800 --> 00:24:56,266
在這邊就沒有用掉了

636
00:24:56,266 --> 00:24:59,400
所以t1,t2生命期也是一個狀態

637
00:24:59,966 --> 00:25:02,533
那比較特別的你要注意看

638
00:25:02,533 --> 00:25:05,300
比如說XY被算出來了對不對

639
00:25:05,766 --> 00:25:08,266
x在這里被用對不對

640
00:25:08,400 --> 00:25:09,800
你在這里算出x

641
00:25:09,800 --> 00:25:12,000
你在這里要用x來右移三位

642
00:25:12,000 --> 00:25:12,666
你在這里

643
00:25:12,666 --> 00:25:13,633
還要用x

644
00:25:13,866 --> 00:25:15,500
你在這里還要用x

645
00:25:15,933 --> 00:25:20,333
所以x要我1234 4個狀態

646
00:25:20,333 --> 00:25:21,300
因為你看

647
00:25:21,366 --> 00:25:24,366
我x在這里算出來這里會用

648
00:25:24,800 --> 00:25:26,233
這里也會用

649
00:25:26,666 --> 00:25:29,366
要活著 所以x要一直被記著

650
00:25:29,700 --> 00:25:32,366
這里要被記著因為後面還會用到x

651
00:25:32,500 --> 00:25:36,166
所以我x要記住4個狀態是這個原因

652
00:25:36,166 --> 00:25:38,366
因為我後面有人會用到x

653
00:25:38,900 --> 00:25:39,533
對不對

654
00:25:39,533 --> 00:25:42,533
所以我x被算出來之後我要活著

655
00:25:42,533 --> 00:25:46,066
活著活著一直到這邊被用完

656
00:25:46,066 --> 00:25:48,933
因為右邊運算結果放到左邊嘛

657
00:25:48,933 --> 00:25:51,366
所以這個變數如果會被用到

658
00:25:51,366 --> 00:25:52,466
那你就要一直活著

659
00:25:53,066 --> 00:25:53,966
那y呢

660
00:25:53,966 --> 00:25:56,266
y不用 你看y這邊算出來之後

661
00:25:56,266 --> 00:25:57,566
只有這個人會用到y

662
00:25:57,566 --> 00:25:59,933
還有沒有等號的右邊要用到y的

663
00:25:59,933 --> 00:26:03,400
沒有 所以y只要一個狀態

664
00:26:03,400 --> 00:26:04,333
那t3呢

665
00:26:04,333 --> 00:26:06,100
t3算出來之後

666
00:26:06,566 --> 00:26:08,133
只要活這邊

667
00:26:08,133 --> 00:26:09,066
那沒有問題

668
00:26:09,066 --> 00:26:10,433
他也是一個狀態

669
00:26:10,566 --> 00:26:12,266
但是T4呢

670
00:26:12,333 --> 00:26:13,500
T4在這邊算

671
00:26:13,500 --> 00:26:15,500
算出來之後這邊才會用到T4

672
00:26:15,500 --> 00:26:18,966
所以T4 算出來之後這里要活著

673
00:26:18,966 --> 00:26:20,866
活著要活兩個狀態

674
00:26:21,300 --> 00:26:23,966
所以這個叫他生命期 是這個意思

675
00:26:23,966 --> 00:26:25,100
因為你想

676
00:26:26,566 --> 00:26:28,700
我把它算出來之後我用了

677
00:26:28,700 --> 00:26:31,033
一個儲存空間把它暫存著

678
00:26:31,166 --> 00:26:31,966
對不對

679
00:26:32,000 --> 00:26:35,066
那這個儲存空間就要一直佔著

680
00:26:35,066 --> 00:26:37,266
因為假設這個值等一下都會被用

681
00:26:37,266 --> 00:26:38,900
這個叫它的生命期

682
00:26:38,933 --> 00:26:39,933
如果這個儲存空間

683
00:26:39,933 --> 00:26:41,333
我今天釋放給別人用

684
00:26:41,333 --> 00:26:45,500
我剛算出來的值就不見了

685
00:26:46,200 --> 00:26:48,500
所以他的前提在於

686
00:26:48,533 --> 00:26:51,600
a b被算出來只要保有一個狀態T1

687
00:26:51,600 --> 00:26:55,500
但是x被算出來之後要活著

688
00:26:55,500 --> 00:26:58,200
活著活著到這邊才會被用完

689
00:26:58,333 --> 00:27:00,900
所以x要換了4個狀態

690
00:27:00,900 --> 00:27:02,133
所以你可以知道

691
00:27:02,133 --> 00:27:03,666
我們這個寫出來是這樣

692
00:27:03,666 --> 00:27:05,233
這邊是狀態

693
00:27:05,866 --> 00:27:07,966
這邊是變數

694
00:27:08,133 --> 00:27:11,000
那個橫軸是狀態

695
00:27:11,733 --> 00:27:14,000
那縱軸是變數

696
00:27:14,000 --> 00:27:16,900
你這樣就可以把它打一個叉

697
00:27:16,900 --> 00:27:19,900
就是那個變數要活著哦

698
00:27:19,900 --> 00:27:21,466
然後打一個記號

699
00:27:21,566 --> 00:27:24,166
所以呢我們就可以算出怎樣

700
00:27:24,600 --> 00:27:28,333
每一個狀態要有幾個變數活著

701
00:27:28,333 --> 00:27:30,300
第一個狀態要有兩個變數

702
00:27:30,300 --> 00:27:33,033
第二個狀態要有兩個變數

703
00:27:33,066 --> 00:27:35,966
第三個狀態要有兩個變數

704
00:27:35,966 --> 00:27:39,033
第四個狀態要有3個變數

705
00:27:39,300 --> 00:27:41,700
第五個狀態要有3個變數

706
00:27:41,733 --> 00:27:43,933
第六個狀態要有兩個變數

707
00:27:43,933 --> 00:27:46,900
第七個狀態要有一個變數

708
00:27:46,900 --> 00:27:48,233
那我問大加

709
00:27:48,300 --> 00:27:51,466
你最少需要幾個儲存空間

710
00:27:51,466 --> 00:27:53,700
這個時候就會來了 就在這邊

711
00:27:54,333 --> 00:27:56,466
對不對 這意思是什麽意思

712
00:27:56,466 --> 00:27:57,100


713
00:27:57,100 --> 00:28:00,033
在狀態一的時候有兩個變數要被記住

714
00:28:00,066 --> 00:28:02,366
狀態2的時候有兩個變數

715
00:28:02,366 --> 00:28:05,600
狀態3的時候有兩個暫存器

716
00:28:05,666 --> 00:28:07,000
需要兩個暫存器

717
00:28:07,000 --> 00:28:08,133
狀態4的時候

718
00:28:08,133 --> 00:28:09,900
因為有三個只要被記住

719
00:28:09,900 --> 00:28:11,766
所以狀態4的時候

720
00:28:11,766 --> 00:28:13,800
至少要有三個暫存器

721
00:28:13,800 --> 00:28:15,266
那代表什麽意思

722
00:28:15,366 --> 00:28:17,700
我整個電路每個狀態跑過

723
00:28:17,700 --> 00:28:21,200
我最少最少需要三個暫存器

724
00:28:22,733 --> 00:28:26,400
要我要取最多的

725
00:28:26,400 --> 00:28:28,566
在某一個狀態同時要活著

726
00:28:28,566 --> 00:28:31,100
的變數最多的

727
00:28:31,100 --> 00:28:32,233
那就是在

728
00:28:32,466 --> 00:28:36,233
狀態4跟狀態5 他都各需要3個暫存器

729
00:28:36,400 --> 00:28:39,166
所以我至少需要3個暫存器

730
00:28:39,166 --> 00:28:40,033
才可以

731
00:28:40,133 --> 00:28:43,033
可以把我這些資料全部都存好

732
00:28:43,500 --> 00:28:45,366
那到這里可以理解

733
00:28:45,366 --> 00:28:47,400
這個叫他生命期

734
00:28:47,400 --> 00:28:49,766
這個這個變數要活這麽久

735
00:28:49,766 --> 00:28:51,466
還有這個變數

736
00:28:51,466 --> 00:28:52,500
只要活一個狀態

737
00:28:52,500 --> 00:28:54,500
那有些變數要活兩個狀態

738
00:28:54,500 --> 00:28:56,366
那我們把它算完之後我就知道

739
00:28:56,366 --> 00:28:59,566
我最少需要3個暫存器

740
00:28:59,566 --> 00:29:01,500
那我最少需要3個暫存器

741
00:29:01,500 --> 00:29:02,433
我可以

742
00:29:02,566 --> 00:29:05,533
我就是假設我的暫存器編號叫R1

743
00:29:05,533 --> 00:29:07,100
R2,R3

744
00:29:07,100 --> 00:29:08,666
我有三個暫存器嘛

745
00:29:08,700 --> 00:29:11,566
分別是R1,R2,R3

746
00:29:11,566 --> 00:29:13,333
那我問大加你怎麽存

747
00:29:13,333 --> 00:29:14,400
其實很簡單

748
00:29:14,400 --> 00:29:15,600
他這里是這樣

749
00:29:16,700 --> 00:29:19,300
你在這個狀態a跟b要活著

750
00:29:19,300 --> 00:29:20,700
所以你看

751
00:29:20,700 --> 00:29:22,900
我在s1這個狀態

752
00:29:22,900 --> 00:29:24,600
我也至少需要兩個暫存器

753
00:29:24,600 --> 00:29:26,400
那我就把號

754
00:29:27,333 --> 00:29:28,600
a的值放到r1

755
00:29:28,600 --> 00:29:29,966
b的值放到r2

756
00:29:29,966 --> 00:29:30,966
對不對然後呢

757
00:29:30,966 --> 00:29:32,433
到了下一個狀態

758
00:29:32,666 --> 00:29:36,333
下一個狀態我我要記住t1跟t2

759
00:29:36,333 --> 00:29:38,366
那因為你a b已經不需要了

760
00:29:38,366 --> 00:29:40,800
所以a b的儲存空間可以空出來

761
00:29:40,866 --> 00:29:43,066
那我t1就放到r1

762
00:29:43,066 --> 00:29:45,266
t2又放到r2

763
00:29:45,266 --> 00:29:47,800
那但是你t1一放進來a會被蓋掉

764
00:29:47,800 --> 00:29:49,400
那因為a後面不會用呢

765
00:29:49,400 --> 00:29:53,000
沒有關系 我們共用暫存器

766
00:29:53,000 --> 00:29:55,166
所以我同一個暫存器里面

767
00:29:55,166 --> 00:29:56,400
有時候存的是a

768
00:29:56,400 --> 00:29:58,000
有時候存的是t1

769
00:29:58,000 --> 00:29:59,500
有時候存的是x

770
00:29:59,566 --> 00:30:01,800
有時候存的是T7 

771
00:30:01,800 --> 00:30:03,933
我就是用一個這樣的概念

772
00:30:03,933 --> 00:30:06,900
所以你看我r1,r2放的是a跟b

773
00:30:06,900 --> 00:30:09,066
那接下來

774
00:30:09,066 --> 00:30:11,500
r1,r2放的是t1,t2

775
00:30:11,733 --> 00:30:13,966
那接下來

776
00:30:14,000 --> 00:30:16,533
你因為你後來就空出來了

777
00:30:16,533 --> 00:30:18,033
我接下來又來一個x

778
00:30:18,066 --> 00:30:20,000
那我x就放到r1

779
00:30:20,533 --> 00:30:21,900
對吧因為

780
00:30:22,066 --> 00:30:24,166
這邊用完r1,r2又空了

781
00:30:24,166 --> 00:30:27,466
所以我x放到r1 那y呢

782
00:30:27,466 --> 00:30:29,300
y我假設我放到r2

783
00:30:29,866 --> 00:30:32,600
哦然後到這里的時候呢

784
00:30:32,600 --> 00:30:33,566
你t4進來

785
00:30:33,566 --> 00:30:35,400
你這個時候t4不能放在r1的

786
00:30:35,400 --> 00:30:37,566
因為x要一直活著

787
00:30:37,566 --> 00:30:39,333
那x放在r1了

788
00:30:39,333 --> 00:30:42,500
你t4只放好放在r2

789
00:30:42,500 --> 00:30:43,600
那你t3

790
00:30:43,600 --> 00:30:46,200
可以放在另外一個暫存器

791
00:30:46,200 --> 00:30:49,366
r3 那接下來x還活著

792
00:30:49,366 --> 00:30:51,200
然後t4還活著

793
00:30:51,200 --> 00:30:54,500
那你新的t5 t5再放進去r3

794
00:30:54,500 --> 00:30:55,400
就是這樣

795
00:30:55,466 --> 00:30:58,033
因為你現在只有3個暫存器

796
00:30:58,966 --> 00:31:02,300
那這個叫暫存器共用

797
00:31:03,200 --> 00:31:05,266
那我們要看結果了

798
00:31:05,266 --> 00:31:06,933
你看了結果你就會知道

799
00:31:06,933 --> 00:31:09,500
在看結果之前我們來再來看一次

800
00:31:09,700 --> 00:31:11,600
如果你完全沒有共用

801
00:31:11,600 --> 00:31:12,766
你想一下

802
00:31:12,866 --> 00:31:15,000
你要做的事情是這個

803
00:31:15,166 --> 00:31:17,500
所以代表什麽意思

804
00:31:17,500 --> 00:31:20,166
我a需要一個暫存器存起來

805
00:31:20,700 --> 00:31:22,566
b需要一個暫存器

806
00:31:22,900 --> 00:31:25,200
T1也要一個 t2也要一個

807
00:31:25,200 --> 00:31:26,400
x也要一個

808
00:31:26,400 --> 00:31:29,333
y也要一個 T3也要一個 T4也要一個

809
00:31:29,333 --> 00:31:31,766
所有等號左邊的那個變數

810
00:31:31,766 --> 00:31:33,700
都要用一個暫存器來存

811
00:31:33,933 --> 00:31:36,633
所以你可以想象我a

812
00:31:36,800 --> 00:31:39,166
b t1 T2 x y

813
00:31:39,266 --> 00:31:41,900
T3 T4 T5 T6 T7

814
00:31:41,900 --> 00:31:44,600
這每一個都要用一個暫存器

815
00:31:44,600 --> 00:31:47,566
所以我這邊要十幾個暫存器

816
00:31:47,566 --> 00:31:49,833
我要十幾個暫存器

817
00:31:49,900 --> 00:31:52,200
才能把這十幾個變數存起來

818
00:31:52,533 --> 00:31:54,366
那我們剛剛

819
00:31:54,366 --> 00:31:56,200
共用了之後我們知道

820
00:31:56,200 --> 00:31:59,566
每個狀態最多只需要3個暫存器

821
00:31:59,600 --> 00:32:00,866


822
00:32:00,966 --> 00:32:01,566


823
00:32:01,566 --> 00:32:04,666
因為生命期大加沒有重疊的關系

824
00:32:04,666 --> 00:32:06,766
所以我只要有3個暫存器

825
00:32:06,766 --> 00:32:07,866
就可以cover了

826
00:32:07,866 --> 00:32:10,766
所以我這個電路就會設計成這樣

827
00:32:11,333 --> 00:32:14,000
你看他只有3個暫存器

828
00:32:15,533 --> 00:32:17,066
 3個暫存器

829
00:32:17,066 --> 00:32:18,266
那他放的是什麽

830
00:32:18,266 --> 00:32:20,633
R1我們要放a t1 x t7

831
00:32:21,200 --> 00:32:23,033


832
00:32:23,400 --> 00:32:25,500
R2放的是這5個

833
00:32:25,533 --> 00:32:28,500
R3放的是這兩個

834
00:32:28,600 --> 00:32:30,833
如果你是用這樣

835
00:32:31,366 --> 00:32:32,900
你看

836
00:32:32,966 --> 00:32:34,900
你在這邊放4個變數

837
00:32:34,900 --> 00:32:36,333
這邊放5個變數

838
00:32:36,333 --> 00:32:37,766
這邊放兩個變數

839
00:32:37,866 --> 00:32:40,800
所以你現在用3個暫存器那共用

840
00:32:41,133 --> 00:32:42,300
再看一次

841
00:32:42,466 --> 00:32:43,900
如果你沒有特別處理

842
00:32:43,900 --> 00:32:46,500
這每一個變數都要用一個暫存器

843
00:32:46,500 --> 00:32:49,100
所以你需要十幾個暫存器

844
00:32:49,966 --> 00:32:52,900
我現在做的register sharing

845
00:32:52,900 --> 00:32:54,566
暫存器共用之後

846
00:32:54,566 --> 00:32:56,300
我只需要三個暫存器

847
00:32:56,300 --> 00:32:58,133
那但是我的電路會覆雜很多

848
00:32:58,133 --> 00:32:59,300
你注意看

849
00:32:59,300 --> 00:33:02,100
什麽叫我的電路覆雜很多

850
00:33:02,100 --> 00:33:02,966
你看一下

851
00:33:02,966 --> 00:33:04,300
第一個動作是什麽

852
00:33:04,300 --> 00:33:07,600
第一個動作是我要把a的

853
00:33:07,900 --> 00:33:09,666
第一個輸入放到a

854
00:33:09,666 --> 00:33:10,866
第二個輸入放到b

855
00:33:10,866 --> 00:33:12,400
所以你可以看到我這個r1

856
00:33:12,400 --> 00:33:13,600
這個暫存器

857
00:33:13,666 --> 00:33:16,966
a第一個輸入要接到這邊r1

858
00:33:16,966 --> 00:33:17,966
因為

859
00:33:18,733 --> 00:33:19,933
第一個輸入進來之後

860
00:33:19,933 --> 00:33:21,600
這個這個就是所謂的a

861
00:33:22,133 --> 00:33:23,666
那r2呢

862
00:33:23,700 --> 00:33:24,966
r2要放什麽

863
00:33:24,966 --> 00:33:27,533
r2要放第二個輸入對不對

864
00:33:27,533 --> 00:33:30,400
所以這里會有一條線放r2

865
00:33:30,400 --> 00:33:31,300
接下來

866
00:33:31,366 --> 00:33:34,566
a的絕對指的結果要接到t1

867
00:33:34,600 --> 00:33:36,166
所以你可以看到你a

868
00:33:36,166 --> 00:33:37,900
剛剛是放在r1嘛

869
00:33:38,100 --> 00:33:39,266
對吧所以你要a

870
00:33:39,900 --> 00:33:43,233
過來這里要有一個絕對值的硬體

871
00:33:43,333 --> 00:33:44,866
可以幫你算絕對值

872
00:33:44,866 --> 00:33:47,400
那a的絕對值之後幫他t1

873
00:33:47,400 --> 00:33:48,666
t1又是r1

874
00:33:48,666 --> 00:33:50,200
所以你會有一條線

875
00:33:51,100 --> 00:33:52,433
拿回去r1

876
00:33:52,533 --> 00:33:55,000
對不對拿回去r1

877
00:33:55,000 --> 00:33:56,833
那你你第二個呢

878
00:33:56,966 --> 00:33:58,666
你要把b

879
00:33:58,733 --> 00:34:01,066
b的絕對值放到t2

880
00:34:01,066 --> 00:34:03,800
那你b放在r2

881
00:34:03,800 --> 00:34:05,133
所以你b的絕對值

882
00:34:05,133 --> 00:34:06,866
這里又有一個絕對值的問題

883
00:34:06,866 --> 00:34:09,500
那做完的時候你又要拉一條線回去

884
00:34:09,500 --> 00:34:13,600
為什麽 因為你的t2是放在r2

885
00:34:13,600 --> 00:34:17,133
所以你r2里面會有另外一個是

886
00:34:17,133 --> 00:34:18,466
那個

887
00:34:18,466 --> 00:34:21,066
所以這個每一條線都

888
00:34:21,066 --> 00:34:23,100
背後都有它的意義

889
00:34:23,100 --> 00:34:28,033
比如說你r1要要產生

890
00:34:28,300 --> 00:34:31,133
a t1 X T7放在r1

891
00:34:31,133 --> 00:34:33,966
所以你看會放在r1的就是a

892
00:34:34,766 --> 00:34:36,800
然後a的絕對值

893
00:34:36,800 --> 00:34:39,166
a的絕對值就是所謂的t1

894
00:34:39,333 --> 00:34:40,666
那x

895
00:34:40,666 --> 00:34:44,000
所以這幾個選擇可以選進去r1

896
00:34:44,000 --> 00:34:46,000
是為了要滿足這四個東西

897
00:34:46,000 --> 00:34:46,866
要放在r1

898
00:34:46,866 --> 00:34:49,000
所以每一條線都有背後都有意義

899
00:34:49,100 --> 00:34:54,300
你這邊有 12345五個變數會放在r2

900
00:34:54,300 --> 00:34:55,000
所以說你可以看到

901
00:34:55,000 --> 00:34:56,866
你看我這里有一個選擇線

902
00:34:56,866 --> 00:34:58,066
有5個輸入

903
00:34:58,900 --> 00:35:02,733
這5個輸入那都會放到r2

904
00:35:02,733 --> 00:35:03,600
那r3呢

905
00:35:03,600 --> 00:35:05,733
r3只有兩個

906
00:35:05,733 --> 00:35:07,900
所以你看r3這邊會有兩條線

907
00:35:07,900 --> 00:35:09,266
然後會放到r3

908
00:35:09,266 --> 00:35:12,800
所以這每一條線你都要特別畫

909
00:35:12,800 --> 00:35:15,000
你為了要做到這一件事情

910
00:35:15,000 --> 00:35:17,666
你要去設計說

911
00:35:17,766 --> 00:35:19,366
哪一個運算的結果

912
00:35:19,366 --> 00:35:21,400
要接到r1或是接到r2

913
00:35:21,400 --> 00:35:23,466
或是接到r3

914
00:35:23,466 --> 00:35:25,733
這每一條線背後都有他的意義

915
00:35:25,733 --> 00:35:27,500
都不是亂接的了

916
00:35:28,700 --> 00:35:29,766


917
00:35:29,766 --> 00:35:32,033
所以現在問題來了

918
00:35:33,133 --> 00:35:33,900
我們跟你講

919
00:35:33,900 --> 00:35:34,533
為什麽

920
00:35:34,533 --> 00:35:38,000
我們跟你說register sharing你不太會做

921
00:35:38,366 --> 00:35:40,766
實際上你學術上會做

922
00:35:40,766 --> 00:35:43,166
為什麽學術上會做就是說

923
00:35:43,400 --> 00:35:45,166
如果你沒有特殊處理

924
00:35:45,166 --> 00:35:47,766
你需要十幾個暫存器對不對

925
00:35:47,766 --> 00:35:49,466
你要十幾個暫存器的話

926
00:35:49,466 --> 00:35:50,900
做你這個電路嘛

927
00:35:51,133 --> 00:35:54,233
經過我這樣整理之後 我發現

928
00:35:54,666 --> 00:35:56,566
最少只需要3個就夠了

929
00:35:56,566 --> 00:35:58,733
因為我們一個狀態是

930
00:35:58,733 --> 00:35:59,866
要三個變數要存

931
00:36:00,100 --> 00:36:02,300
所以我就用了三個暫停器

932
00:36:02,600 --> 00:36:05,266
那我先把三個暫存器擺出來

933
00:36:05,266 --> 00:36:06,900
然後呢這每一條接線

934
00:36:06,900 --> 00:36:08,966
我再去看我的電路是怎樣

935
00:36:08,966 --> 00:36:11,766
我的接線就會一條一條把它接起來

936
00:36:12,400 --> 00:36:13,266
我問你

937
00:36:13,266 --> 00:36:14,933
為什麽說學術上有意義

938
00:36:14,933 --> 00:36:18,566
當學術上這個花時間去做

939
00:36:18,566 --> 00:36:21,466
那你賺了七八個暫存器

940
00:36:21,466 --> 00:36:22,700
因為你只用了3個

941
00:36:22,700 --> 00:36:24,200
比原來十幾倍還少

942
00:36:24,200 --> 00:36:25,800
所以你能賺到8個暫存器

943
00:36:25,800 --> 00:36:27,066
9個暫存器

944
00:36:28,600 --> 00:36:30,200
但是你花的是什麽

945
00:36:30,200 --> 00:36:31,933
你花的是勞力

946
00:36:31,933 --> 00:36:32,966
因為你每一條線

947
00:36:32,966 --> 00:36:34,466
你要特別去接

948
00:36:35,266 --> 00:36:36,466
這是第一件事

949
00:36:36,466 --> 00:36:39,100
所以你要自己手動去把它接好

950
00:36:39,100 --> 00:36:40,300
那第二個呢

951
00:36:40,400 --> 00:36:43,833
你的verilog code全部要down到gate level來寫

952
00:36:43,966 --> 00:36:46,066
看你要這里要選一個選擇器

953
00:36:46,066 --> 00:36:47,866
這邊要一個站成器

954
00:36:47,866 --> 00:36:50,166
然後這這些模組你要一個一個接

955
00:36:50,166 --> 00:36:52,866
你沒有辦法在很高檔次

956
00:36:52,866 --> 00:36:54,400
很behavior去寫

957
00:36:54,400 --> 00:36:56,266
沒有辦法

958
00:36:56,266 --> 00:36:59,066
所以你要做一個就是sharing

959
00:37:00,266 --> 00:37:03,766
你今天一決定要做 你就只好手動做

960
00:37:03,766 --> 00:37:06,933
然後你要把你的電路down到gate level

961
00:37:06,933 --> 00:37:09,300
所以我才會說他學術上有意義

962
00:37:09,300 --> 00:37:12,800
但是你在公司不會希望這樣的

963
00:37:12,800 --> 00:37:14,700
因為你為了賺這幾個暫存器

964
00:37:14,700 --> 00:37:17,033
你整個設計時間會拉很長

965
00:37:17,133 --> 00:37:19,866
而且你debug也可能會變得很久

966
00:37:20,200 --> 00:37:21,766
所以他

967
00:37:21,766 --> 00:37:24,600
不一定會需要 不一定會需要

968
00:37:24,600 --> 00:37:27,966
但是你可以知道他怎麽做的

969
00:37:27,966 --> 00:37:29,366
register sharing就是這樣

970
00:37:30,000 --> 00:37:31,166
什麽時候可以共用

971
00:37:31,166 --> 00:37:32,933
你用的時候我不會用

972
00:37:32,933 --> 00:37:33,733
等到

973
00:37:33,866 --> 00:37:36,533
我存你的值之後我的值就被蓋掉了

974
00:37:36,533 --> 00:37:38,566
所以前面可能我先存

975
00:37:39,000 --> 00:37:40,933
那我的生命期一結束

976
00:37:40,933 --> 00:37:43,166
隨便誰要來用我這個儲存空間

977
00:37:43,166 --> 00:37:43,900
我就不管了

978
00:37:43,900 --> 00:37:45,766
因為我不會再被用到

979
00:37:45,766 --> 00:37:47,400
這他的意思就是這樣

980
00:37:47,533 --> 00:37:49,666
我AB在這里被用到

981
00:37:49,666 --> 00:37:51,066
後面都沒有用到AB

982
00:37:51,066 --> 00:37:53,800
我這個AB空間就可以讓出來

983
00:37:53,800 --> 00:37:55,566
那我x這里存了

984
00:37:55,566 --> 00:37:58,066
但是因為後面會有人用到x

985
00:37:58,300 --> 00:38:00,500
所以我x就要活久一點

986
00:38:01,133 --> 00:38:03,466
那這個這個用的是

987
00:38:03,466 --> 00:38:05,400
所以Register sharing是這樣

988
00:38:05,400 --> 00:38:07,166
但是我剛剛已經一再強調

989
00:38:07,166 --> 00:38:09,666
他不一定會用

990
00:38:09,666 --> 00:38:12,400
因為他用下去你的成本很高

991
00:38:12,400 --> 00:38:14,400
我所謂的成本就是說你的

992
00:38:14,766 --> 00:38:16,666
設計成本會變高

993
00:38:16,666 --> 00:38:18,666
雖然你的硬體成本是降低

994
00:38:18,666 --> 00:38:21,666
但是你的設計成本是變高的了

995
00:38:21,933 --> 00:38:22,766


996
00:38:23,666 --> 00:38:26,366
那講完第一個resource sharing

997
00:38:26,366 --> 00:38:29,333
第二個我們要看的就叫所謂的functional

998
00:38:29,333 --> 00:38:30,766
unit sharing

999
00:38:30,766 --> 00:38:32,266
就是

1000
00:38:32,266 --> 00:38:35,566
運算這個這個是儲存單元

1001
00:38:35,566 --> 00:38:38,600
這邊儲存單元講的就是暫存器

1002
00:38:38,800 --> 00:38:40,466
暫存器的共用

1003
00:38:40,466 --> 00:38:43,333
那第二個共用是functional unit

1004
00:38:43,333 --> 00:38:46,966
functional unit就是這些加減乘除

1005
00:38:47,000 --> 00:38:48,333
這些絕對值

1006
00:38:48,333 --> 00:38:50,600
這些運算的共用

1007
00:38:50,800 --> 00:38:51,833


1008
00:38:51,900 --> 00:38:54,700
那什麽叫functional unit的共用呢

1009
00:38:54,700 --> 00:38:54,966


1010
00:38:54,966 --> 00:38:58,666
我們舉剛剛那個例子你可以看到

1011
00:38:59,133 --> 00:39:01,666
我今天要做加

1012
00:39:01,933 --> 00:39:04,333
假設我在上面要做加

1013
00:39:04,333 --> 00:39:07,300
我在下面要做減

1014
00:39:07,300 --> 00:39:08,400
上面做加

1015
00:39:08,400 --> 00:39:10,266
下面要做加

1016
00:39:10,266 --> 00:39:12,400
那我當然可以用同樣一個加法器

1017
00:39:12,400 --> 00:39:13,666
這樣做兩次

1018
00:39:13,700 --> 00:39:16,000
可是我如果上面要做加

1019
00:39:16,133 --> 00:39:17,766
要下面要做減

1020
00:39:17,766 --> 00:39:19,566
那你如果沒有特別設計

1021
00:39:19,566 --> 00:39:21,800
那你就要用一個加法器

1022
00:39:21,933 --> 00:39:23,366
用一個減法器

1023
00:39:23,966 --> 00:39:27,366
那所謂functional unit的功能是這樣

1024
00:39:27,366 --> 00:39:27,966
我可以

1025
00:39:27,966 --> 00:39:29,900
我可不可以設計一個硬體

1026
00:39:29,900 --> 00:39:32,766
既可以做加又可以做減

1027
00:39:32,800 --> 00:39:34,700
這所謂的加減器

1028
00:39:35,300 --> 00:39:36,700
那我來選擇

1029
00:39:36,700 --> 00:39:38,000
我來選擇說

1030
00:39:38,000 --> 00:39:39,833
我這次要做的是加

1031
00:39:39,966 --> 00:39:42,866
下一次要做的是減

1032
00:39:42,866 --> 00:39:44,766
所以如果你可以設計一個這樣

1033
00:39:44,766 --> 00:39:47,700
這個叫functional unit sharing

1034
00:39:47,700 --> 00:39:49,266
所以呢他是這樣

1035
00:39:49,366 --> 00:39:51,166
你同樣的運算

1036
00:39:51,166 --> 00:39:52,500
我們可以做sharing

1037
00:39:52,500 --> 00:39:54,400
比如說這個加跟這個加

1038
00:39:54,400 --> 00:39:58,000
我可以用同一個加法器去做兩次

1039
00:39:58,000 --> 00:40:00,200
因為他是在不同時間被做嘛

1040
00:40:00,200 --> 00:40:01,866
這個叫functional unit sharing

1041
00:40:01,866 --> 00:40:05,200
這是一種在同樣的運算的共享

1042
00:40:05,200 --> 00:40:06,033
我今天

1043
00:40:06,066 --> 00:40:08,866
這個加跟這個加用同樣一個硬體

1044
00:40:09,300 --> 00:40:11,266
因為你如果沒有特殊設計

1045
00:40:11,266 --> 00:40:12,366
在verilog里面

1046
00:40:12,366 --> 00:40:14,466
我們是可以用不同的兩個硬體

1047
00:40:14,466 --> 00:40:16,400
平行做的

1048
00:40:16,400 --> 00:40:18,466
那我現在可以用一個硬體

1049
00:40:18,666 --> 00:40:19,700
先加這個

1050
00:40:19,700 --> 00:40:20,933
然後再加這個

1051
00:40:20,933 --> 00:40:22,966
因為他在不同時間

1052
00:40:22,966 --> 00:40:25,400
那我也可以設計一個加減器

1053
00:40:25,400 --> 00:40:27,566
既可以做加又可以做減

1054
00:40:27,566 --> 00:40:29,866
所以這個functional unit sharing

1055
00:40:30,200 --> 00:40:33,500
包含我共享同樣的運算

1056
00:40:34,200 --> 00:40:36,366
第二個我是共享什麽

1057
00:40:36,366 --> 00:40:37,666
不同的運算

1058
00:40:37,666 --> 00:40:39,566
但是是類似的

1059
00:40:40,200 --> 00:40:42,500
那這個

1060
00:40:43,366 --> 00:40:46,100
functional unit sharing跟剛剛Register sharing

1061
00:40:46,100 --> 00:40:46,800
一樣

1062
00:40:46,800 --> 00:40:49,600
我們再來看一下共享的概念是什麽

1063
00:40:50,666 --> 00:40:53,200
今天我這個東西存在這里

1064
00:40:53,200 --> 00:40:55,766
那我存的是記住我的東西

1065
00:40:55,766 --> 00:40:57,500
那什麽時候可以存你

1066
00:40:58,100 --> 00:41:00,200
我今天我的生命期結束了

1067
00:41:00,200 --> 00:41:03,400
我算出來的值別人已經不會再用了

1068
00:41:03,400 --> 00:41:05,600
就可以把我空間讓給你

1069
00:41:05,600 --> 00:41:08,066
你就可以來這裡

1070
00:41:08,066 --> 00:41:10,766
那這個運算的共享也是一樣

1071
00:41:11,333 --> 00:41:12,733
我今天如

1072
00:41:12,733 --> 00:41:17,133
果這個加跟這個加是在不同時間的

1073
00:41:17,133 --> 00:41:19,733
那我就可以用一個加法的硬體

1074
00:41:19,733 --> 00:41:21,366
然後讓他做兩次

1075
00:41:21,400 --> 00:41:22,100
可是

1076
00:41:22,100 --> 00:41:25,100
什麽時候不能用一個硬體做兩次

1077
00:41:25,100 --> 00:41:27,666
如果你在加的時候我也要加

1078
00:41:27,666 --> 00:41:28,866
那他也要加

1079
00:41:28,866 --> 00:41:31,200
那我們要三個硬體

1080
00:41:31,200 --> 00:41:33,100
因為你加的時候我也要加

1081
00:41:33,100 --> 00:41:33,933
那他也要加

1082
00:41:33,933 --> 00:41:35,066
我們再加不可能

1083
00:41:35,300 --> 00:41:37,700
那這時候我就要3個硬體

1084
00:41:37,700 --> 00:41:40,600
所以到底那個共享要那個

1085
00:41:41,000 --> 00:41:43,966
那個加法的生命期是不一樣的

1086
00:41:44,166 --> 00:41:46,100
你加的時候我不會加

1087
00:41:46,100 --> 00:41:48,000
那他加的時候我也不會加

1088
00:41:48,000 --> 00:41:49,566
我們大家的時間不一樣

1089
00:41:49,566 --> 00:41:51,800
就可以用一個加法做三次

1090
00:41:51,933 --> 00:41:53,766
可是如果你加的時候

1091
00:41:53,766 --> 00:41:56,666
你這個加的生命期

1092
00:41:57,166 --> 00:42:00,300
跟我這個加的生命期是重疊的

1093
00:42:00,300 --> 00:42:01,266
那也不行

1094
00:42:01,266 --> 00:42:02,700
因為你這樣說我也要加

1095
00:42:02,700 --> 00:42:04,566
那就要兩個不同的硬體

1096
00:42:04,566 --> 00:42:05,800
那如果還有另外一個人

1097
00:42:05,800 --> 00:42:06,700
生命期也是這樣

1098
00:42:06,700 --> 00:42:09,400
那我就要三個不一樣的硬體

1099
00:42:09,400 --> 00:42:10,266
所以

1100
00:42:10,900 --> 00:42:12,700
只要是講到Sharing

1101
00:42:13,066 --> 00:42:14,466
這你都要注意

1102
00:42:14,466 --> 00:42:16,533
就是那個生命期的問題

1103
00:42:16,533 --> 00:42:19,233
這有沒有重疊 有沒有重疊

1104
00:42:19,400 --> 00:42:20,533


1105
00:42:20,533 --> 00:42:23,966
所以這個叫做functional unit sharing

1106
00:42:23,966 --> 00:42:25,900
那這functional unit sharing

1107
00:42:26,266 --> 00:42:28,900
代表什麽 就是說

1108
00:42:28,900 --> 00:42:30,900
比如說我可以用一個硬體

1109
00:42:30,966 --> 00:42:33,266
它可以做最小值

1110
00:42:33,900 --> 00:42:34,200


1111
00:42:34,200 --> 00:42:37,133
那我也可以用一個硬體就做最大值

1112
00:42:37,133 --> 00:42:38,333
然後我有一個硬體

1113
00:42:38,333 --> 00:42:40,000
可以做最大值或最小值

1114
00:42:40,000 --> 00:42:41,166
那你注意看

1115
00:42:41,466 --> 00:42:43,500
不管你是最小值或最大值

1116
00:42:43,500 --> 00:42:45,500
這個硬體都是用

1117
00:42:45,500 --> 00:42:46,766
一個減法器

1118
00:42:46,766 --> 00:42:48,133
然後再加一些電路

1119
00:42:48,133 --> 00:42:50,666
就可以變成一個最小值

1120
00:42:50,766 --> 00:42:53,600
換句話說這個電路應該可以做減法

1121
00:42:53,600 --> 00:42:55,700
那也可以做最小值

1122
00:42:55,700 --> 00:42:57,766
因為他這里是一個

1123
00:42:57,766 --> 00:42:58,566
substractor

1124
00:42:58,566 --> 00:43:00,766
他是一個減法

1125
00:43:00,766 --> 00:43:03,000
那你也可以把它稍微變形一下

1126
00:43:03,000 --> 00:43:04,933
他可以做最大值

1127
00:43:04,933 --> 00:43:06,800
你也可以把它再變形一下

1128
00:43:06,800 --> 00:43:08,700
他既可以做最大值或最小值

1129
00:43:08,700 --> 00:43:10,900
就看你怎麼選擇

1130
00:43:10,900 --> 00:43:13,333
那這個叫做硬體的共用

1131
00:43:13,333 --> 00:43:14,400
functional unit sharing

1132
00:43:14,500 --> 00:43:16,966
那同樣的你左移

1133
00:43:16,966 --> 00:43:18,966
你右移一位跟右移三位

1134
00:43:18,966 --> 00:43:21,400
你也可以把它作在一起

1135
00:43:21,400 --> 00:43:21,700
不過

1136
00:43:21,700 --> 00:43:24,333
因為其實移位器成本比較低

1137
00:43:24,333 --> 00:43:27,100
這個比較沒有太大的意義

1138
00:43:27,100 --> 00:43:29,000
所以我們再看往下

1139
00:43:29,000 --> 00:43:31,366
你看他現在這里設計了一個硬體

1140
00:43:31,366 --> 00:43:32,766
這個硬體可以做什麽

1141
00:43:32,766 --> 00:43:33,900
絕對值

1142
00:43:33,933 --> 00:43:36,400
也可以做最小值也可以做最大值

1143
00:43:36,400 --> 00:43:38,800
換句話說這個硬體

1144
00:43:38,800 --> 00:43:40,400
因為他是用了一個加法器

1145
00:43:40,400 --> 00:43:41,600
跟兩個選擇器

1146
00:43:41,600 --> 00:43:43,433
還有一個XOR

1147
00:43:43,466 --> 00:43:46,166
這硬體既可以做絕對值

1148
00:43:46,166 --> 00:43:49,300
那也可以做最小值也可以做最大值

1149
00:43:50,000 --> 00:43:51,666
那那這個硬體呢

1150
00:43:51,666 --> 00:43:54,266
這個硬體可以做加

1151
00:43:55,000 --> 00:43:57,466
也可以做絕對值也可以做減

1152
00:43:57,466 --> 00:43:58,966
他基本上要用一個加法器

1153
00:43:58,966 --> 00:44:00,733
再加上一些其他邏輯閘

1154
00:44:00,733 --> 00:44:03,766
他可以同時做這三個function

1155
00:44:03,766 --> 00:44:05,300
所以這個叫做

1156
00:44:05,300 --> 00:44:05,966
functional unit sharing

1157
00:44:05,966 --> 00:44:07,200
我這個硬體

1158
00:44:07,200 --> 00:44:09,066
同時可以做不同的

1159
00:44:09,066 --> 00:44:10,866
就是不同

1160
00:44:11,966 --> 00:44:14,933
但是

1161
00:44:14,933 --> 00:44:16,566
類似的運算

1162
00:44:16,566 --> 00:44:17,366


1163
00:44:17,500 --> 00:44:20,866
那這個是我們到這邊的理解了

1164
00:44:20,866 --> 00:44:22,700
那我們休息一下

1165
00:44:22,700 --> 00:44:24,200
然後再從這邊繼續

1166
00:44:24,200 --> 00:44:25,600
就休息10分鐘吧

